<?xml version="1.0" encoding="utf-8"?>


<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN">
    <title type="text">慢慢的个人博客</title>
    <subtitle type="html">MemE 是一个强大且可高度定制的 GoHugo 博客主题，专为个人博客设计。</subtitle>
    <updated>2022-02-20T20:28:20&#43;08:00</updated>
    <id>https://marin-man.github.io/</id>
    <link rel="alternate" type="text/html" href="https://marin-man.github.io/" />
    <link rel="self" type="application/atom&#43;xml" href="https://marin-man.github.io/atom.xml" />
    <author>
            <name>慢慢</name>
            <uri>https://marin-man.github.io/</uri>
            
                <email>marin-man@163.com</email>
            </author>
    <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights>
    <generator uri="https://gohugo.io/" version="0.92.2">Hugo</generator>
        <entry>
            <title type="text">数据链路层</title>
            <link rel="alternate" type="text/html" href="https://marin-man.github.io/posts/network-link-layer/" />
            <id>https://marin-man.github.io/posts/network-link-layer/</id>
            <updated>2022-02-20T20:19:11&#43;08:00</updated>
            <published>2022-02-20T01:12:52&#43;08:00</published>
            <author>
                    <name>慢慢</name>
                    <uri>https://marin-man.github.io/</uri>
                    <email>marin-man@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">什么是数据链路层的基本特征 数据链路层的基本特征为：封装成帧，透明传输，差错检测。 什么是封装成帧 慢慢：封装成帧就是在一段数据的前后分别添加首部和尾部，从而构成一个……</summary>
            
                <content type="html">&lt;h3 id=&#34;什么是数据链路层的基本特征&#34;&gt;什么是数据链路层的基本特征&lt;/h3&gt;
&lt;p&gt;数据链路层的基本特征为：封装成帧，透明传输，差错检测。&lt;/p&gt;
&lt;h3 id=&#34;什么是封装成帧&#34;&gt;什么是封装成帧&lt;/h3&gt;
&lt;p&gt;慢慢：封装成帧就是在一段数据的前后分别添加首部和尾部，从而构成一个帧。所有互联网上传送的数据都是以分组（IP 数据报）为传送单位，网络层的 IP 数据报传送到数据链路层就成为帧的数据部分，再添加首部和尾部，构成一个完整的帧。&lt;/p&gt;
&lt;h3 id=&#34;什么是透明传输&#34;&gt;什么是透明传输&lt;/h3&gt;
&lt;p&gt;由于帧的开始和结束的标记使用专门的控制字符。但如果数据中出现了开始或结束字符，我们应当想方法让他们保持原意，于是就得要通过转移字符。让数据链路层看不到妨碍数据传输的东西，就叫做透明传输。&lt;/p&gt;
&lt;h3 id=&#34;什么是差错检测&#34;&gt;什么是差错检测&lt;/h3&gt;
&lt;p&gt;现实中的通信链路都不会是理想的，也就是说比特在传输中可能会出现差错。数据链路层采用循环冗余法（CRC）来检测传输过来的数据是否有差错，如果有，则直接抛弃。&lt;/p&gt;
&lt;h3 id=&#34;什么是-csmacd-协议&#34;&gt;什么是 CSMA/CD 协议&lt;/h3&gt;
&lt;p&gt;CSMA/CD (Carrier Sense Multiple Access with Collision Detection)，即载波监听，多点接入，碰撞检测。&lt;/p&gt;
&lt;p&gt;以前的以太网是使用总线的形式来传输数据，这样就避免不了总线上的不同点同时发送数据的情况。&lt;/p&gt;
&lt;p&gt;多点接入：许多计算机以多点的方式连接在一条总线上。
载波监听：用电子技术检测总线上有没有其他计算机也在发送。不管在发送前还是在发送中，每个站都必须不同地检测信道。在发送前检测信道是为了判断信道没有人发送，获得发送权。在发送中检测信道是为了即使发现有没有其他站地发送和本站发送的碰撞。
碰撞检测：虽然在发送前需要检测信道为空才能发送信息，但也有一种情况发生：两个站都没有检测到信道被占用，并几乎同时发送信息，就像两个小朋友同时举手发言。当发现碰撞检测时，两个站都会取消发送，同时发出人为干扰信号，通知其他点也不要发送。然后执行截断二进制退避算法，双方推迟不同的时间发送数据。&lt;/p&gt;
&lt;p&gt;但现在的网络采用了星形结构来传输，所以不会出现信号在一条线上发生冲突的情况。&lt;/p&gt;
&lt;h3 id=&#34;什么是-mac-地址&#34;&gt;什么是 MAC 地址&lt;/h3&gt;
&lt;p&gt;MAC 地址又称为物理地址或硬件地址。每个网卡，路由器都有一个对应的 MAC 地址。&lt;/p&gt;
</content>
            
            
            
                
                
                
                    
                    
                    
                        
                            <category scheme="https://marin-man.github.io/posts/" term="posts\" label="posts\" />
                        
                    
                
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://marin-man.github.io/categories/2022/" term="2022" label="2022" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://marin-man.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" term="计算机网络" label="计算机网络" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">网络架构</title>
            <link rel="alternate" type="text/html" href="https://marin-man.github.io/posts/network-based/" />
            <id>https://marin-man.github.io/posts/network-based/</id>
            <updated>2022-02-20T20:15:06&#43;08:00</updated>
            <published>2022-02-20T01:12:52&#43;08:00</published>
            <author>
                    <name>慢慢</name>
                    <uri>https://marin-man.github.io/</uri>
                    <email>marin-man@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">什么是 OSI 七层模型 OSI(Open System Interconnection Reference Model)，是一种概念模型，由国际标准化组织提出，一个试图使各种计算机在世界范围内互连为网络的标准架构。 七层模型为： 物理层：制定底层数……</summary>
            
                <content type="html">&lt;h3 id=&#34;什么是-osi-七层模型&#34;&gt;什么是 OSI 七层模型&lt;/h3&gt;
&lt;p&gt;OSI(Open System Interconnection Reference Model)，是一种概念模型，由国际标准化组织提出，一个试图使各种计算机在世界范围内互连为网络的标准架构。&lt;/p&gt;
&lt;p&gt;七层模型为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;物理层：制定底层数据传输的标准，如机械特性，电器特性和功能特性，网线和网卡标准等。&lt;/li&gt;
&lt;li&gt;数据链路层：定义数据的格式，如何传输，如何标识，主要为封装成帧，透明传输，差错检测。&lt;/li&gt;
&lt;li&gt;网络层：定义 IP 编址，定义路由功能。&lt;/li&gt;
&lt;li&gt;传输层：端到端传输数据的基本传输。&lt;/li&gt;
&lt;li&gt;会话层：控制应用层序之间会话能力，如将不同软件数据分发给不同软件。&lt;/li&gt;
&lt;li&gt;表示层：数据格式标识，基本压缩，加密功能等。&lt;/li&gt;
&lt;li&gt;应用层：各种应用程序，包括 web 应用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每一层实现各自的功能和协议，并完成与相邻层的接口通信。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://b3logfile.com/file/2020/05/image-664dda43.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;什么是五层模型&#34;&gt;什么是五层模型&lt;/h3&gt;
&lt;p&gt;五层模型将网络分为物理层，数据链路层，网络层，应用层。&lt;/p&gt;
&lt;h3 id=&#34;两者有什么关系呢&#34;&gt;两者有什么关系呢？&lt;/h3&gt;
&lt;p&gt;OSI 七层协议是一个标准，而非实现，五层模型是一个实现的应用模型，五层模型由七层简化合并而来。&lt;/p&gt;
&lt;h3 id=&#34;不同层的数据被称为什么&#34;&gt;不同层的数据被称为什么？&lt;/h3&gt;
&lt;p&gt;在物理层时数据称为比特流，链路层时为帧，网络层时为数据报，数据链路层为字节流/字符流。&lt;/p&gt;
</content>
            
            
            
                
                
                
                    
                    
                    
                        
                            <category scheme="https://marin-man.github.io/posts/" term="posts\" label="posts\" />
                        
                    
                
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://marin-man.github.io/categories/2022/" term="2022" label="2022" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://marin-man.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" term="计算机网络" label="计算机网络" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">CAP 理论</title>
            <link rel="alternate" type="text/html" href="https://marin-man.github.io/posts/distribute-cap/" />
            <id>https://marin-man.github.io/posts/distribute-cap/</id>
            <updated>2022-02-19T18:31:02&#43;08:00</updated>
            <published>2022-02-19T01:12:52&#43;08:00</published>
            <author>
                    <name>慢慢</name>
                    <uri>https://marin-man.github.io/</uri>
                    <email>marin-man@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">什么是 CAP 理论 CAP 原则指的是一个分布式系统中，Consistency(一致性)，Avaliablity(可用性)，Partition tolerance(分区容错性)……</summary>
            
                <content type="html">&lt;h3 id=&#34;什么是-cap-理论&#34;&gt;什么是 CAP 理论&lt;/h3&gt;
&lt;p&gt;CAP 原则指的是一个分布式系统中，Consistency(一致性)，Avaliablity(可用性)，Partition tolerance(分区容错性)，三者不可兼得。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一致性：在分布式环境下，一致性是指数据在多个副本之间能否保持一致的特性。&lt;/li&gt;
&lt;li&gt;可用性：可用性是指系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。&lt;/li&gt;
&lt;li&gt;分区容错性：分区容错性约束了一个分布式系统具有如下特性：分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;为什么三者不能同时满足&#34;&gt;为什么三者不能同时满足&lt;/h3&gt;
&lt;p&gt;假设现在有两台服务器，一台跑 A 服务和数据库 V1，一台跑服务 B 和数据库 V2，V1 和 V2 是同步的。在满足分区容错性下，A 或 B 一台宕机都不会影响到其他服务的执行。但当 V1 和 V2 的通信断开时，数据库就不能同步。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;牺牲一致性：A 用 v1 的数据库，B 用 v2 的数据库，两者都没有同步&lt;/li&gt;
&lt;li&gt;牺牲可用性：禁止 A 和 B 正常服务，直到两种能同步才开启服务。&lt;/li&gt;
&lt;li&gt;牺牲分区容错性：如果不用分区容错性，则整个系统可以不用分布式来搭建，能保证强一致性和可用性，但如果机器挂了，整个服务也崩了。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;什么是-base-理论&#34;&gt;什么是 BASE 理论&lt;/h3&gt;
&lt;p&gt;BASE 就是 Basically Available(基本可用)，Soft state(软状态)，Eventually consistent(最终一致性)，是对 CAP 中一致性和可用性权衡的结果。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基本可用：指分布式在出现不可预知故障的时候，允许损失部分可用性。
&lt;ul&gt;
&lt;li&gt;响应时间上的损失：一个在线搜索引擎需要 0.5s 内返回给用户相应的查询结果，但由于出现异常（比如系统部分机房发送端点或断网故障）查询结果的响应时间增加到了 1~2s&lt;/li&gt;
&lt;li&gt;功能上的损失：在购物高峰时，为了保证购物系统的稳定性，部分消费者可能会被引导到一个降级页面。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;软状态：指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性。
最终一致性：系统中的所有数据副本，在经过一段时间的同步后，最终能够到达一个一致的状态。&lt;/li&gt;
&lt;/ul&gt;
</content>
            
            
            
                
                
                
                    
                    
                    
                        
                            <category scheme="https://marin-man.github.io/posts/" term="posts\" label="posts\" />
                        
                    
                
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://marin-man.github.io/categories/2022/" term="2022" label="2022" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://marin-man.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" term="分布式" label="分布式" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Redis Cluster 集群</title>
            <link rel="alternate" type="text/html" href="https://marin-man.github.io/posts/redis-cluster/" />
            <id>https://marin-man.github.io/posts/redis-cluster/</id>
            <updated>2022-02-19T18:17:38&#43;08:00</updated>
            <published>2022-02-19T01:12:52&#43;08:00</published>
            <author>
                    <name>慢慢</name>
                    <uri>https://marin-man.github.io/</uri>
                    <email>marin-man@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">什么是 Cluster 集群？ Cluster 集群是通过搭建多个主从节点，每对主从节点存储不同的数据，从而扩大存储容量，解决单线程写的瓶颈，增大吞吐量。 在不考虑哨兵的情况下，Cluster 至……</summary>
            
                <content type="html">&lt;h3 id=&#34;什么是-cluster-集群&#34;&gt;什么是 Cluster 集群？&lt;/h3&gt;
&lt;p&gt;Cluster 集群是通过搭建多个主从节点，每对主从节点存储不同的数据，从而扩大存储容量，解决单线程写的瓶颈，增大吞吐量。&lt;/p&gt;
&lt;p&gt;在不考虑哨兵的情况下，Cluster 至少需要三个 master 节点，每个 master 节点至少需要一个 slave。&lt;/p&gt;
&lt;h3 id=&#34;cluster-的优缺点有哪些&#34;&gt;Cluster 的优缺点有哪些？&lt;/h3&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无中心架构；&lt;/li&gt;
&lt;li&gt;数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布；&lt;/li&gt;
&lt;li&gt;可扩展：可线性扩展，动态删除节点。&lt;/li&gt;
&lt;li&gt;高可用：部分节点不可用时，集群仍然可用，并可以通过增加 slave，哨兵等做为数据副本，实现故障自动转移；&lt;/li&gt;
&lt;li&gt;降低运维成本，提高系统的扩展性和可用性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可能不支持多个 key 的混合计算。例如两个 key 分布在不同节点上，就很难只用 redis 对其求交集等。&lt;/li&gt;
&lt;li&gt;分库扩容可能比较复杂。&lt;/li&gt;
&lt;li&gt;client 实现复杂，需要实现 smart client，先得到 key 的具体位置，并且也要定时更新。
数据通过异步复制，不保证数据的强一致性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;如何搭建-cluster-集群&#34;&gt;如何搭建 Cluster 集群？&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;所有的节点的 redis.conf 文件都添加 &lt;code&gt;cluster-enabled yes&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;启动所有节点，同时选择一个节点输入命令 &lt;code&gt;redis-cli --cluster create 节点1IP:端口 节点2IP:端口 …… --cluster-replicas 1&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;如何去得知-key-存储在哪个节点分区&#34;&gt;如何去得知 Key 存储在哪个节点（分区）？&lt;/h3&gt;
&lt;p&gt;现在有三种常用的分区方法：节点取余分区，一致性哈希分区，虚拟槽分区。&lt;/p&gt;
&lt;h4 id=&#34;1-节点取余分区&#34;&gt;1. 节点取余分区&lt;/h4&gt;
&lt;p&gt;对每个 key 进行取余，并根据余数放到不同的分区中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：计算简单&lt;/li&gt;
&lt;li&gt;缺点：当要扩容时，需要把所有数据重新取余一遍。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2-一致性哈希分区&#34;&gt;2. 一致性哈希分区&lt;/h4&gt;
&lt;p&gt;运用哈希环（创建一个大小为 2&lt;sup&gt;32&lt;/sup&gt;-1 的环形数组），每个节点都选择数组中的一个点。当添加 key 时，把 key 也放到数组上面，同时根据顺时针的方式，找到离得最近的节点，存到这个节点里。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：增加或减少节点很容易：当增加节点时，在数组中选择一个位置，并且逆时针将与上一个节点之间的数据都转移到此节点上。&lt;/li&gt;
&lt;li&gt;缺点：数组初始时需要很大，也可以采用链地址法。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;3-虚拟槽分区&#34;&gt;3. 虚拟槽分区&lt;/h4&gt;
&lt;p&gt;预设虚拟槽，槽的大小比节点的大小小得多（即一个节点上有多个虚拟槽），将数据映射到虚拟槽上，将虚拟槽映射到节点上。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：这是 redis 默认的分区方式，扩容或缩容时是以槽为单位，可以自身控制扩容、缩容需要的代价&lt;/li&gt;
&lt;/ul&gt;
</content>
            
            
            
                
                
                
                    
                    
                    
                        
                            <category scheme="https://marin-man.github.io/posts/" term="posts\" label="posts\" />
                        
                    
                
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://marin-man.github.io/categories/2022/" term="2022" label="2022" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://marin-man.github.io/tags/redis/" term="Redis" label="Redis" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Redis 主从集群</title>
            <link rel="alternate" type="text/html" href="https://marin-man.github.io/posts/redis-master/" />
            <id>https://marin-man.github.io/posts/redis-master/</id>
            <updated>2022-02-19T17:48:31&#43;08:00</updated>
            <published>2022-02-19T01:12:52&#43;08:00</published>
            <author>
                    <name>慢慢</name>
                    <uri>https://marin-man.github.io/</uri>
                    <email>marin-man@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">什么是集群 为了系统的可靠性或扩大系统资源，我们一般会通过多台机器来共享资源、分担费用、共用信道设备及服务等。 Redis 有哪几种集群模式 Redis 场景的集群模式有：主从模式，哨兵……</summary>
            
                <content type="html">&lt;h3 id=&#34;什么是集群&#34;&gt;什么是集群&lt;/h3&gt;
&lt;p&gt;为了系统的可靠性或扩大系统资源，我们一般会通过多台机器来共享资源、分担费用、共用信道设备及服务等。&lt;/p&gt;
&lt;h3 id=&#34;redis-有哪几种集群模式&#34;&gt;Redis 有哪几种集群模式&lt;/h3&gt;
&lt;p&gt;Redis 场景的集群模式有：主从模式，哨兵模式，cluster 模式。&lt;/p&gt;
&lt;h3 id=&#34;什么是主从集群&#34;&gt;什么是主从集群&lt;/h3&gt;
&lt;p&gt;通过搭建多台 redis 主机，两者间存储相同的数据，从而分散单主机下的请求压力。&lt;/p&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;高可靠性：一方面采用主从机架构，当主机宕机时，能手动将从机顶替主机，防止系统崩溃。另一方面，多台机器都会进行相应的数据持久化操作，从而备份多份数据。&lt;/li&gt;
&lt;li&gt;读写分离策略：从节点可以扩展主库节点的读能力，有效应对大并发量的读操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;故障恢复发杂：因为没有哨兵去检测主机从机之间的状态并处理故障转移，所以我们得要去开发监控程序，当主机宕机时能及时通知我们并手动去切换主从节点。&lt;/li&gt;
&lt;li&gt;主库的写能力收到单机的限制。&lt;/li&gt;
&lt;li&gt;系统的存储能力收到单机的限制。&lt;/li&gt;
&lt;li&gt;主从同步时是通过网络进行传输，难免会出现一些错误，即使有了很多的检错手段，但还是会出现个节点间数据不一致的问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;怎么实现主从复制&#34;&gt;怎么实现主从复制&lt;/h3&gt;
&lt;h4 id=&#34;理论部分&#34;&gt;理论部分&lt;/h4&gt;
&lt;p&gt;主从复制有两个阶段：初始化阶段和运行阶段。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始化阶段：
&lt;ul&gt;
&lt;li&gt;从服务器启动；&lt;/li&gt;
&lt;li&gt;从服务器连接到主机，发送 SYNC 命令；&lt;/li&gt;
&lt;li&gt;主服务器收到 SYNC 命令后，开始执行 BGSAVE 命令，保持当前快照并生成 RDB 文件，同时在此过程中用缓存区记录下这段时间的执行命令，防止数据丢失；&lt;/li&gt;
&lt;li&gt;主服务器执行完 BGSAVE 后，向从服务器发送快照文件，并且也在缓存区记录下这个时期执行的命令；&lt;/li&gt;
&lt;li&gt;从服务器收到快照文件后，丢失所有旧数据，重写载入收到的快照；&lt;/li&gt;
&lt;li&gt;主服务器快照发送完毕后旧向从服务器发送缓存区里记录下的命令；&lt;/li&gt;
&lt;li&gt;从服务器完成快照的输入，开始接收命令请求，执行来自主服务器缓冲区的写命令。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;运行阶段：
&lt;ul&gt;
&lt;li&gt;主服务器每执行一个命令，就会向从服务器发送相同的命令，这个也叫做增量更新。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;实操部分&#34;&gt;实操部分&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yml&#34; data-lang=&#34;yml&#34;&gt;&lt;span class=&#34;l&#34;&gt;// 主机 `redis.conf` 文件&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;role&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;master    // 角色&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;connected_slaves&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;// 从服务器的个数 &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yml&#34; data-lang=&#34;yml&#34;&gt;&lt;span class=&#34;l&#34;&gt;// 从机 `redis.conf` 文件&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;role&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;slave&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;replicaof 主机ip 主机port&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;如果传输的过程中数据丢失了redis-会怎样保证数据的可靠性&#34;&gt;如果传输的过程中数据丢失了，Redis 会怎样保证数据的可靠性？&lt;/h3&gt;
&lt;p&gt;从 Redis2.8 开始，就支持了主从复制的断点续传。master 和 slave 都保存一个 replica offset，里面记录了当前数据的偏移量。slave 会定期的向 master 发送此偏移量，并和自己的偏移量比较，从而知道了 slave 是否还差一些数据，并将数据发送过去。&lt;/p&gt;
&lt;p&gt;同理，当传输过程中数据丢失时，slave 也只保存了丢失前的偏移量，等一段时间后会自动跟 master 比较当前的偏移量。&lt;/p&gt;
&lt;h3 id=&#34;在主从模式下明明一个键过期了为什么还可能会读到&#34;&gt;在主从模式下，明明一个键过期了，为什么还可能会读到？&lt;/h3&gt;
&lt;p&gt;因为 Redis 的从库是无法主从区删除已过期的 key。它的实现策略是通过主库去判断该 key 是否过期，若过期，则删除并且向 Slave 发出删除 key 的指令。又由于 Redis 的主库键过期是采用惰性删除的策略（前文有讲），所以，当读从库时，并不会触发过期判断的策略，从而不删除键。&lt;/p&gt;
&lt;p&gt;解决方法：&lt;/p&gt;
&lt;p&gt;编写一段程序，定期通过 Scan 扫库。扫库的作用是访问 master 里所有的 key，这样就会触发所有 key 的过期检测，从而删除过期的 key。但这样也会极大降低性能。
使用 Redis3.2 以上的版本，因为其新增了一个特性来解决这个问题。增加了 key 是否过期以及对主从库的判断，如果 key 已过期，当前访问的Master则返回 null；当前访问的是从库，且执行的是只读命令也返回 null。源码如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8zMTMzMjA5LTQ3YTNmMzI0NWI5Y2VkMzM_aW1hZ2VNb2dyMi9hdXRvLW9yaWVudC9zdHJpcHxpbWFnZVZpZXcyLzIvdy82NDAvZm9ybWF0L3dlYnA?x-oss-process=image/format,png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
</content>
            
            
            
                
                
                
                    
                    
                    
                        
                            <category scheme="https://marin-man.github.io/posts/" term="posts\" label="posts\" />
                        
                    
                
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://marin-man.github.io/categories/2022/" term="2022" label="2022" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://marin-man.github.io/tags/redis/" term="Redis" label="Redis" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Redis 事务</title>
            <link rel="alternate" type="text/html" href="https://marin-man.github.io/posts/redis-transtation/" />
            <id>https://marin-man.github.io/posts/redis-transtation/</id>
            <updated>2022-02-19T18:30:20&#43;08:00</updated>
            <published>2022-02-19T01:12:52&#43;08:00</published>
            <author>
                    <name>慢慢</name>
                    <uri>https://marin-man.github.io/</uri>
                    <email>marin-man@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">什么是事务？ 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。事务有四个非常重要的……</summary>
            
                <content type="html">&lt;h3 id=&#34;什么是事务&#34;&gt;什么是事务？&lt;/h3&gt;
&lt;p&gt;事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。事务有四个非常重要的特点：ACID。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A(原子性)：原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。&lt;/li&gt;
&lt;li&gt;C(一致性)：事务前后数据的完整性必须保持一致。&lt;/li&gt;
&lt;li&gt;I(隔离性)：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。&lt;/li&gt;
&lt;li&gt;D(持久性)：持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;reids-事务的概念&#34;&gt;Reids 事务的概念&lt;/h3&gt;
&lt;p&gt;Redis 事务的本质是通过 MULTI, EXEC, WATCH 等一组命令的集合。Redis 事务的执行过程为：开启事务 -&amp;gt; 命令队列 -&amp;gt; 序列化 -&amp;gt; 串行执行。&lt;/p&gt;
&lt;p&gt;串行执行即若出错，则后面停止，前面的并没有进行回滚。所以 Redis 默认是不支持事务（没有原子性）操作的。&lt;/p&gt;
&lt;h3 id=&#34;为什么-redis-不支持回滚操作呢&#34;&gt;为什么 Redis 不支持回滚操作呢？&lt;/h3&gt;
&lt;p&gt;Redis 运行指令是单线程的，同时 Redis 保证了一个事务的所有指令有序执行，即不会插入其他的语句，保证了事务的原子性。所以不会出现不同进行同时修改的问题，所以在程序员不写错代码的情况下是不会出错的，不需要回滚机制。&lt;/p&gt;
&lt;h3 id=&#34;redis-能保证隔离性吗&#34;&gt;Redis 能保证隔离性吗？&lt;/h3&gt;
&lt;p&gt;慢慢：由于 Redis 是单进程程序，并且它保证在执行事务时不会对事务进行终端，所以不会产生别的线程干扰事务执行的情况，所以保证隔离性。&lt;/p&gt;
</content>
            
            
            
                
                
                
                    
                    
                    
                        
                            <category scheme="https://marin-man.github.io/posts/" term="posts\" label="posts\" />
                        
                    
                
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://marin-man.github.io/categories/2022/" term="2022" label="2022" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://marin-man.github.io/tags/redis/" term="Redis" label="Redis" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Redis 哨兵集群</title>
            <link rel="alternate" type="text/html" href="https://marin-man.github.io/posts/redis-sentinel/" />
            <id>https://marin-man.github.io/posts/redis-sentinel/</id>
            <updated>2022-02-19T18:10:14&#43;08:00</updated>
            <published>2022-02-19T01:12:52&#43;08:00</published>
            <author>
                    <name>慢慢</name>
                    <uri>https://marin-man.github.io/</uri>
                    <email>marin-man@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">什么是哨兵？ 我们知道，在主从集群的基础上，如果主机宕机的话，我们就得要手动去将从机升级为主机，使系统正常运行。而哨兵就是为了代替我们人的存在，它也是一个独立的进……</summary>
            
                <content type="html">&lt;h3 id=&#34;什么是哨兵&#34;&gt;什么是哨兵？&lt;/h3&gt;
&lt;p&gt;我们知道，在主从集群的基础上，如果主机宕机的话，我们就得要手动去将从机升级为主机，使系统正常运行。而哨兵就是为了代替我们人的存在，它也是一个独立的进程，不做任何具体的业务，只是来监视主从机的运行状况，并在出现故障时自动处理。&lt;/p&gt;
&lt;h3 id=&#34;为什么要有哨兵集群呢&#34;&gt;为什么要有哨兵集群呢？&lt;/h3&gt;
&lt;p&gt;一个哨兵的情况下，如果哨兵和主机都挂了，那么整个系统就不可用了。为了系统更加高可用，避免出现哨兵宕机，主节点同时宕机而使系统崩溃的情况。&lt;/p&gt;
&lt;h3 id=&#34;哨兵是怎么工作的&#34;&gt;哨兵是怎么工作的？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;每个哨兵都会定时向它所知的 master，slave 以及其他的哨兵发送一条 ping 命令；&lt;/li&gt;
&lt;li&gt;每个节点收到 ping 命令后都会回复 pong；&lt;/li&gt;
&lt;li&gt;如果一个节点距离最后一次回复 pong 的时间超过了 down-after-milliseconds 所规定的值，那么这个实例就会被当前的哨兵标记为主观下线；&lt;/li&gt;
&lt;li&gt;如果一个 master 被标记为主观下线，则哨兵就会以更加短的时间发送信息给 master 以确保真正下线；&lt;/li&gt;
&lt;li&gt;当有了足够数量的哨兵在指定的时间范围内确认 master 的确进入了主观下线状态，则 master 就会转为客观下线状态；&lt;/li&gt;
&lt;li&gt;当 Master 被所有哨兵标记为客观下线，哨兵向所有的 Slave 发送 INFO 命令，重新选举新的 master；&lt;/li&gt;
&lt;li&gt;如果没有足够数量的哨兵同意 master 已下线，并且 master 重新向哨兵发送 ping 回复命令，master 的主观下线状态就会被移除。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;哨兵集群部署简单；&lt;/li&gt;
&lt;li&gt;能够解决 redis 主从模式下的高可用切换问题；&lt;/li&gt;
&lt;li&gt;方便实现 redis 数据节点的线性扩展，轻松突破 reids 单线程瓶颈；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;相对于主从模式要更复杂；&lt;/li&gt;
&lt;li&gt;开启进程会消耗一定的资源；&lt;/li&gt;
&lt;li&gt;哨兵主要针对 redis 主节点的高可用切换，对 redis 的数据节点做失败判断，分为主观下线和客观线性，并不执行故障转移；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;redis-是如何选举主节点的&#34;&gt;Redis 是如何选举主节点的？&lt;/h3&gt;
&lt;p&gt;Redis 选举主节点需要两个步骤，第一个步从哨兵节点中选择一个 Leader，第二步是让这个 leader 在执行故障转移操作。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;选举 Leader：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;哨兵发现 master 节点下线，便把他标记为主观下线，并通知其他节点也对此 master 进行检查。&lt;/li&gt;
&lt;li&gt;哨兵多次判断此 master 为主观下线后，就向其他哨兵广播一条信息，请求同意自己作为 Leader。其他节点收到信息后，如果在此之前没有发送过同意，就能够发送同意（即每个哨兵只能同意一个节点）。&lt;/li&gt;
&lt;li&gt;当某个节点收到的同意数量超过一半时，就升级为 leader，否则再进行一轮选举。（这种选举算法为 Raft 算法）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;故障转移&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Leader 选举完成后就执行故障转移操作：每个 slave 节点都将自己的优先级，offest，runid 发送给 Leader，Leader 根据这三者的顺序选举出最大的节点，将其升级为 master 节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;具体实践&#34;&gt;具体实践&lt;/h3&gt;
&lt;p&gt;在配置好主从的情况下，配置哨兵节点：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-conf&#34; data-lang=&#34;conf&#34;&gt;// sentinel.conf
sentinel monitor 主机名称 主机ip 主机端口 监听个数
sentinel auth-pass 主机名称 主机密码
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;虽然我们在 sentinel 的配置文件中只配置了主节点，没有配置从节点，但哨兵会去主节点中获取从节点的信息，从而实现整个 Redis 的监控。&lt;/p&gt;
&lt;h3 id=&#34;为什么哨兵集群必须部署两个以上的节点呢&#34;&gt;为什么哨兵集群必须部署两个以上的节点呢？&lt;/h3&gt;
&lt;p&gt;假设只有两个哨兵节点，如果 Master 和哨兵1 都宕机了，此时哨兵2知道 Master 宕机，对其进行主观下线，并且想升级为 Leader，但没有其他节点响应，所以 Master 就一直不被切换。&lt;/p&gt;
&lt;h3 id=&#34;在哨兵模式下还会不会出现数据丢失的问题&#34;&gt;在哨兵模式下，还会不会出现数据丢失的问题？&lt;/h3&gt;
&lt;p&gt;哨兵只是为了保证在 Master 挂掉的时候能快速选举出新的 Master，从而保证服务的高可用；并不会处理数据同步间出现的问题。&lt;/p&gt;
&lt;p&gt;数据丢失主要有两方面：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;异步复制导致数据丢失：由于 Master -&amp;gt; Slave 的复制是异步的，如果 Master 还没复制数据到 Slave 就宕机了，并且哨兵把 Slave 选举为 Master，那么这部分数据就丢失了。&lt;/li&gt;
&lt;li&gt;脑裂导致数据丢失：当某个 Master 突然脱离了正常网络（不是宕机，可能是部分网络瘫痪），并且哨兵集群认为它宕机了，重新选举 Master。但这个时候旧 Master 还能顺利的接收客户端发送的数据，而哨兵此时维护新 Master。当旧 Master 网络回复后，则会同步新 Master 的数据，导致数据丢失。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;脑裂的解决方法：通过配置文件设置如果 Master 和 Slave 节点超过一定的时间无法联系，则 Master 拒绝写请求。&lt;/p&gt;
&lt;h3 id=&#34;有什么方式可以实现数据一致呢&#34;&gt;有什么方式可以实现数据一致呢？&lt;/h3&gt;
&lt;p&gt;由 CAP 理论得知，一致性和可用性并不能同时成立。为了达到数据的强一致性，我们必须先暂停下服务，等数据同步完再开启服务。以 RedLock （获取分布式锁）为例：一开始有 5 台 Master 节点（都是作为主节点），每当要获取锁时，需要通过轮询的方式从 5 台 Master 节点中获取锁（短暂的服务停顿，等数据同步），保证超过 1/2 的节点都能获取锁后才能继续执行，否则就会超时，获取锁失败。&lt;/p&gt;
</content>
            
            
            
                
                
                
                    
                    
                    
                        
                            <category scheme="https://marin-man.github.io/posts/" term="posts\" label="posts\" />
                        
                    
                
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://marin-man.github.io/categories/2022/" term="2022" label="2022" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://marin-man.github.io/tags/redis/" term="Redis" label="Redis" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Redis 基础</title>
            <link rel="alternate" type="text/html" href="https://marin-man.github.io/posts/redis-based/" />
            <id>https://marin-man.github.io/posts/redis-based/</id>
            <updated>2022-02-19T03:18:24&#43;08:00</updated>
            <published>2022-02-19T01:12:52&#43;08:00</published>
            <author>
                    <name>慢慢</name>
                    <uri>https://marin-man.github.io/</uri>
                    <email>marin-man@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">什么是 Redis？ Redis (Remote Dictionary Server 远程字典服务) 是一个开源的使用 ANSI C 语言编写，支持网络，可基于内存亦可持久化的日志型，key-value 数据库，提供多种语言的 API。 Redis……</summary>
            
                <content type="html">&lt;h3 id=&#34;什么是-redis&#34;&gt;什么是 Redis？&lt;/h3&gt;
&lt;p&gt;Redis (Remote Dictionary Server 远程字典服务) 是一个开源的使用 ANSI C 语言编写，支持网络，可基于内存亦可持久化的日志型，key-value 数据库，提供多种语言的 API。&lt;/p&gt;
&lt;h3 id=&#34;redis-有哪些常用功能&#34;&gt;Redis 有哪些常用功能？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;数据缓存&lt;/li&gt;
&lt;li&gt;数据持久化&lt;/li&gt;
&lt;li&gt;支持事务&lt;/li&gt;
&lt;li&gt;消息队列&lt;/li&gt;
&lt;li&gt;分布式锁&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;小qredis-有哪些数据类型&#34;&gt;小Q：Redis 有哪些数据类型？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;String：Redis 最基础的数据结构。&lt;/li&gt;
&lt;li&gt;Hash：一种键值对的结构，其相对于字符串序列化结构更加直观，并且在更新操作上更加便捷。（底层是 ziplist 或 hashtable）&lt;/li&gt;
&lt;li&gt;List：基于双向链表，可以充当栈和队列的角色。（底层是 ziplist 或 linkedlist）&lt;/li&gt;
&lt;li&gt;Set：用来保证集合中不能有重复元素。（底层是 intset 或 hashtable）&lt;/li&gt;
&lt;li&gt;zset：有序集合，类似于 treeSet，它保留了 set 不能有重复元素外，还将集合里的元素进行排序。（底层是 skiplist）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;小q什么是-ziplist&#34;&gt;小Q：什么是 ziplist？&lt;/h3&gt;
&lt;p&gt;慢慢：ziplist 是由一系列特殊编码的，连续内存快组成的顺序存储结构，类似于数组。ziplist 在内存中是连续的，所以每次插入时，都会重新 malloc 空间，保证其连续性。一般情况下在数据量小的时候使用。&lt;/p&gt;
&lt;h3 id=&#34;小qredis-有哪些使用场景&#34;&gt;小Q：Redis 有哪些使用场景？&lt;/h3&gt;
&lt;p&gt;慢慢：redis 的应用很广泛。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;缓存：减轻 MYSQL 的查询压力，提升系统性能；&lt;/li&gt;
&lt;li&gt;排行榜：利用 Redis 的 zset 实现；&lt;/li&gt;
&lt;li&gt;计算器/限速器：利用 redis 中原子性的自增操作，我们可以统计类似用户点赞、用户访问数等。这类操作如果用 MYSQL，频繁的读写会带来相当大的压力，限速器比较典型的使用场景是限制某个用户访问某个 API 的频率，常用的有抢购时，防止用户疯狂点击开来不必要的压力；&lt;/li&gt;
&lt;li&gt;好友关系：利用集合的一些命令，如交集，并集，差集等，可以方便实现一些共同好友，共同爱好之类的功能；&lt;/li&gt;
&lt;li&gt;消息队列：除了 Redis 自身的发布/订阅模式，我们也可以利用 List 来实现一个队列机制。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;小qredis-如何解决-hash-冲突&#34;&gt;小Q：Redis 如何解决 hash 冲突？&lt;/h3&gt;
&lt;p&gt;慢慢：Redis 采用链地址法解决 hash 冲突。即一个桶里面的元素使用链表保持。但当链表过长时就会导致性能变差。Redis 为了追求快，使用了两个全局哈希表，用于 rehash 操作。&lt;/p&gt;
&lt;h3 id=&#34;小qrehash扩容-的具体操作&#34;&gt;小Q：rehash(扩容) 的具体操作&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;开始时默认使用 hash table1 保持键值对数据，hash table2 没有分配空间。&lt;/li&gt;
&lt;li&gt;当数据越来越多，就会触发 rehash 操作。&lt;/li&gt;
&lt;li&gt;给 hash table2 分配 hash table1 多一倍的空间。&lt;/li&gt;
&lt;li&gt;将 hash1 的数据重映射到 hash2 中&lt;/li&gt;
&lt;li&gt;释放 hash1 的空间。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;重映射的过长不是一次性的，因为这也会造成 redis 长时间阻塞，无法提供服务。它采用渐进式 rehash，每次处理客户端请求的时候，会先从 hash table1 中找到对应的桶，将桶里面的数据移动到 hash table2 中，这样就将 rehash 操作分散到多次请求中，避免耗时阻塞。&lt;/strong&gt;&lt;/p&gt;
</content>
            
            
            
                
                
                
                    
                    
                    
                        
                            <category scheme="https://marin-man.github.io/posts/" term="posts\" label="posts\" />
                        
                    
                
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://marin-man.github.io/categories/2022/" term="2022" label="2022" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://marin-man.github.io/tags/redis/" term="Redis" label="Redis" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Redis 存储</title>
            <link rel="alternate" type="text/html" href="https://marin-man.github.io/posts/redis-store/" />
            <id>https://marin-man.github.io/posts/redis-store/</id>
            <updated>2022-02-19T03:25:35&#43;08:00</updated>
            <published>2022-02-19T01:12:52&#43;08:00</published>
            <author>
                    <name>慢慢</name>
                    <uri>https://marin-man.github.io/</uri>
                    <email>marin-man@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">Redis 是如何持久化的？ Redis 有两种持久化方式： AOF：独立日志文件（主流方式），优先级较高，其是通过将命令写入缓存区，缓冲区再根据策略同步到硬盘，并且还会定期通过 fork() 子进……</summary>
            
                <content type="html">&lt;h3 id=&#34;redis-是如何持久化的&#34;&gt;Redis 是如何持久化的？&lt;/h3&gt;
&lt;p&gt;Redis 有两种持久化方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AOF：独立日志文件（主流方式），优先级较高，其是通过将命令写入缓存区，缓冲区再根据策略同步到硬盘，并且还会定期通过 fork() 子进程对 AOF 进行重写，优化存储空间。&lt;/li&gt;
&lt;li&gt;RDB：采用数据快照的存储方式。通过 fork() 子进程，根据内存生成的临时快照，再存储到硬盘或对原有文件进行原子替换。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;AOF 和 RDB 的区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AOF 文件比 RDB 更新频率高，优先使用 AOF 还原数据；&lt;/li&gt;
&lt;li&gt;AOF 比 RDB 更安全也更大；&lt;/li&gt;
&lt;li&gt;RDB 性能比 AOF 好；&lt;/li&gt;
&lt;li&gt;如果两个都配置了，优先加载 AOF。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;什么是缓存击穿&#34;&gt;什么是缓存击穿？&lt;/h3&gt;
&lt;p&gt;当缓存中的 key 失效时，且同时有很多请求打在 key 上，这个时候的这些请求都会访问到数据库，造成数据库压力变大。&lt;/p&gt;
&lt;p&gt;解决方案：设置热点数据不过时，或采用锁（必要时是分布式锁）保证每个 key 只有一个线程去查询数据库。&lt;/p&gt;
&lt;h3 id=&#34;什么是缓存穿透&#34;&gt;什么是缓存穿透？&lt;/h3&gt;
&lt;p&gt;当很多请求都请求到一个更不不存在的数据时，由于缓存中也肯定没有此数据，所以所有请求都访问到了数据库。&lt;/p&gt;
&lt;p&gt;解决方案：用空对象替代，或者采用布隆过滤器，记录下能找不到的值，下次请求时，如果没有就能直接得到。&lt;/p&gt;
&lt;h3 id=&#34;什么是缓存雪崩&#34;&gt;什么是缓存雪崩？&lt;/h3&gt;
&lt;p&gt;当缓存中大量的值同时失效，并且有很多请求都要请求这些值时，所有请求都会访问到数据库。&lt;/p&gt;
&lt;p&gt;解决方案：通过缓存预热，搭建数据库集群分散压力，服务降级：直接不查数据库，返回默认值。&lt;/p&gt;
&lt;h3 id=&#34;什么是布隆过滤器&#34;&gt;什么是布隆过滤器？&lt;/h3&gt;
&lt;p&gt;布隆过滤器：用于大数据的排重，将每条数据不同 Hash 计算得到不同的指纹，将指纹映射到一个大的按位存储的空间。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：空间和时间效率都很高。&lt;/li&gt;
&lt;li&gt;缺点：随着存入的元素增加，误算率随之增大。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用范围：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;大数据去重：bitmap，Bloom Fiter&lt;/li&gt;
&lt;li&gt;网络爬虫 Url 去重：BitSet + hash，Bloom Filter&lt;/li&gt;
&lt;/ul&gt;
</content>
            
            
            
                
                
                
                    
                    
                    
                        
                            <category scheme="https://marin-man.github.io/posts/" term="posts\" label="posts\" />
                        
                    
                
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://marin-man.github.io/categories/2022/" term="2022" label="2022" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://marin-man.github.io/tags/redis/" term="Redis" label="Redis" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Redis 数据类型</title>
            <link rel="alternate" type="text/html" href="https://marin-man.github.io/posts/redis-data-type/" />
            <id>https://marin-man.github.io/posts/redis-data-type/</id>
            <updated>2022-02-19T17:37:19&#43;08:00</updated>
            <published>2022-02-19T01:12:52&#43;08:00</published>
            <author>
                    <name>慢慢</name>
                    <uri>https://marin-man.github.io/</uri>
                    <email>marin-man@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">Redis 有哪些数据类型 Redis 有 String、List、Hash、Set、ZSet、Bitmap、Hyperloglog 等，下面来详细说下这几种类型的底层实现。 1. String String 底层实……</summary>
            
                <content type="html">&lt;h2 id=&#34;redis-有哪些数据类型&#34;&gt;Redis 有哪些数据类型&lt;/h2&gt;
&lt;p&gt;        Redis 有 String、List、Hash、Set、ZSet、Bitmap、Hyperloglog 等，下面来详细说下这几种类型的底层实现。&lt;/p&gt;
&lt;h3 id=&#34;1-string&#34;&gt;1. String&lt;/h3&gt;
&lt;p&gt;String 底层实现分为两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;整数：长度小于 21 且能够转化为整数的字符串&lt;/li&gt;
&lt;li&gt;SDS (Simple Dynamic String 简单动态字符串)：len 长度 + free 剩余未使用空间 + buf 字符数组&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SDS 的好处：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可以根据 len 快速获取字符串长度&lt;/li&gt;
&lt;li&gt;当修改字符串长度时可以减少内存分配次数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用场景：缓存，限流，计数器，分布式锁，分布式 Session&lt;/p&gt;
&lt;p&gt;基本命令：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-redis&#34; data-lang=&#34;redis&#34;&gt;SET key value                           GET key
MSET key value [key value]              MGET [key1 key2]
INCR key                                DECR key
SETEX key second value                  SETNX key value
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;2-list&#34;&gt;2. List&lt;/h3&gt;
&lt;p&gt;List 在 Reids 中主要用于实现队列或栈，在不同版本有不同的实现方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;旧版本：
&lt;ul&gt;
&lt;li&gt;数据量小时：ZipList 压缩链表&lt;/li&gt;
&lt;li&gt;数据量大时：LinkedList 双向链表&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;新版本：
&lt;ul&gt;
&lt;li&gt;数据量小时：ZipList 压缩链表&lt;/li&gt;
&lt;li&gt;数据量大时：QuickList 快速链表&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ZipList：压缩链表，由一系列特殊编码的连续内存块组成的顺序存储结构，其不固定长度数组，每个元素大小通过元素头的 len 来确定。&lt;/p&gt;
&lt;p&gt;QuickList：也是一个链表结构，只不过链表节点维护一个 ZipList，从而压缩内存空间。&lt;/p&gt;
&lt;p&gt;使用场景：微博关注人时间轴列表，简单队列&lt;/p&gt;
&lt;p&gt;基本命令&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;LPOP # key 移除第一个元素    RPOP # 移除最后一个元素
LPUSH                   RPUSH
LSET key index value   # 通过索引设置列表元素的值
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;3-hash&#34;&gt;3. Hash&lt;/h3&gt;
&lt;p&gt;Hash 是一个类似 Map 的映射结构，其底层有两种实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据量小时：ZipList&lt;/li&gt;
&lt;li&gt;数据量大时：HashTable&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用场景：存储用户信息，用户主页访问量，文章点赞数据&lt;/p&gt;
&lt;p&gt;基本命令&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;HGET key field          HGETALL key         HMGET key field1 field2
HSET key field value    HMSET key field1 value1 field2 value2
HSETNX key field value
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;4-set&#34;&gt;4. Set&lt;/h3&gt;
&lt;p&gt;Set 是一个用于去重的数据结构，底层实现：HashTable 的 Key 部分&lt;/p&gt;
&lt;p&gt;使用场景：点赞，踩，标签，好友关系&lt;/p&gt;
&lt;p&gt;基本命令&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;SADD key member1 member2
SDIFF key1 key2  # 返回第一个集合与其他集合的差异
SINTER key1 key2  # 返回交集
SREM key member1
SPOP key  # 移除集合的一个随机元素
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;5-zset&#34;&gt;5. ZSet&lt;/h4&gt;
&lt;p&gt;ZSet 是一个排序，去重的数据结构框架，其底层有两种实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据量小时：ZipList&lt;/li&gt;
&lt;li&gt;数据量大时：SkipList&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;采用 ZipList 的原因：由于数据量少，O(n) 复杂度的查询和 O(logN) 的查询时间相差不大，同时，ZipList 能很好的压缩内存，节约空间。&lt;/p&gt;
&lt;p&gt;SkipList：跳跃表，其根据数据量会分为多层结构，当查询时从上层往下找，复杂度为 O(logN)，当插入时，会先找到插入的位置，同时生成一个随机数，来表示此节点要生成多少层。SkipList 相较于二叉搜索树的好处是其不用严格的按照左右节点，通过随机数的大小来判断此节点的层数。&lt;/p&gt;
&lt;p&gt;使用场景：排行榜，分页数据&lt;/p&gt;
&lt;p&gt;基本命令：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ZADD key score1 member1 score2 member2
ZCOUNT key min max  # 范围内的成员数
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;6-bitmap&#34;&gt;6. BitMap&lt;/h3&gt;
&lt;p&gt;BitMap 通过每一个来记录一些数据的状态，达到压缩内存的效果。&lt;/p&gt;
&lt;p&gt;使用场景：用户签到，火车座位在不同站点时的状态&lt;/p&gt;
&lt;p&gt;基本命令：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;setbit name 1 1
getbit name 1    # 1
setbit name 3 1
bitcount bittest 0 0  # 表示第一个字节（8位）0 的个数
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;7-hyperloglog&#34;&gt;7. HyperLogLog&lt;/h3&gt;
&lt;p&gt;HyperLogLog 用于基数统计，每个 HyperLogLog 只需要花费 12K 内存，就可以计算接近 2^16 个不同元素的基数，且错误率在 0.82%，这和 set （元素越多内存越大）形成对比。但是 HyperLogLog 只会根据输入元素来计算基数，不会存储元素本身，所以 HyperLogLog 不能输出各个元素。但其也能作为交集，返回元素个数。&lt;/p&gt;
&lt;p&gt;基数：在数组中出现过的值，例如：{1, 3, 5, 7, 5, 7, 8} 的基数集为 {1, 3, 5, 7, 8}&lt;/p&gt;
&lt;p&gt;底层原理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;假设一个人抛硬币，每轮可以抛任意次，但抛到正面就要结束掉。若它抛到为 &lt;code&gt;001&lt;/code&gt;，因为 &lt;code&gt;001&lt;/code&gt; 出现的概率为 1/8，于是我们可以断定抛了 8 次。&lt;/li&gt;
&lt;li&gt;同理，我们可以根据数组中的数据的二进制位 1 出现的位置，来大概估计这组数据中基数的个数，同时设置多个槽，再根据加权平均值得出最终的结果。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基本命令：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;PFADD key element1 element2
PFCOUNT key1 key2  # 查找基数的个数，若多个 key，交集
&lt;/code&gt;&lt;/pre&gt;</content>
            
            
            
                
                
                
                    
                    
                    
                        
                            <category scheme="https://marin-man.github.io/posts/" term="posts\" label="posts\" />
                        
                    
                
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://marin-man.github.io/categories/2022/" term="2022" label="2022" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://marin-man.github.io/tags/redis/" term="Redis" label="Redis" />
                            
                        
                    
                
            
        </entry>
    
</feed>
