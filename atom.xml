<?xml version="1.0" encoding="utf-8"?>


<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN">
    <title type="text">慢慢的个人博客</title>
    <subtitle type="html">MemE 是一个强大且可高度定制的 GoHugo 博客主题，专为个人博客设计。</subtitle>
    <updated>2022-02-19T17:49:50&#43;08:00</updated>
    <id>https://marin-man.github.io/</id>
    <link rel="alternate" type="text/html" href="https://marin-man.github.io/" />
    <link rel="self" type="application/atom&#43;xml" href="https://marin-man.github.io/atom.xml" />
    <author>
            <name>慢慢</name>
            <uri>https://marin-man.github.io/</uri>
            
                <email>marin-man@163.com</email>
            </author>
    <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights>
    <generator uri="https://gohugo.io/" version="0.92.2">Hugo</generator>
        <entry>
            <title type="text">Redis 主从集群</title>
            <link rel="alternate" type="text/html" href="https://marin-man.github.io/posts/redis-master/" />
            <id>https://marin-man.github.io/posts/redis-master/</id>
            <updated>2022-02-19T17:48:31&#43;08:00</updated>
            <published>2022-02-19T01:12:52&#43;08:00</published>
            <author>
                    <name>慢慢</name>
                    <uri>https://marin-man.github.io/</uri>
                    <email>marin-man@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">什么是集群 为了系统的可靠性或扩大系统资源，我们一般会通过多台机器来共享资源、分担费用、共用信道设备及服务等。 Redis 有哪几种集群模式 Redis 场景的集群模式有：主从模式，哨兵……</summary>
            
                <content type="html">&lt;h3 id=&#34;什么是集群&#34;&gt;什么是集群&lt;/h3&gt;
&lt;p&gt;为了系统的可靠性或扩大系统资源，我们一般会通过多台机器来共享资源、分担费用、共用信道设备及服务等。&lt;/p&gt;
&lt;h3 id=&#34;redis-有哪几种集群模式&#34;&gt;Redis 有哪几种集群模式&lt;/h3&gt;
&lt;p&gt;Redis 场景的集群模式有：主从模式，哨兵模式，cluster 模式。&lt;/p&gt;
&lt;h3 id=&#34;什么是主从集群&#34;&gt;什么是主从集群&lt;/h3&gt;
&lt;p&gt;通过搭建多台 redis 主机，两者间存储相同的数据，从而分散单主机下的请求压力。&lt;/p&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;高可靠性：一方面采用主从机架构，当主机宕机时，能手动将从机顶替主机，防止系统崩溃。另一方面，多台机器都会进行相应的数据持久化操作，从而备份多份数据。&lt;/li&gt;
&lt;li&gt;读写分离策略：从节点可以扩展主库节点的读能力，有效应对大并发量的读操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;故障恢复发杂：因为没有哨兵去检测主机从机之间的状态并处理故障转移，所以我们得要去开发监控程序，当主机宕机时能及时通知我们并手动去切换主从节点。&lt;/li&gt;
&lt;li&gt;主库的写能力收到单机的限制。&lt;/li&gt;
&lt;li&gt;系统的存储能力收到单机的限制。&lt;/li&gt;
&lt;li&gt;主从同步时是通过网络进行传输，难免会出现一些错误，即使有了很多的检错手段，但还是会出现个节点间数据不一致的问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;怎么实现主从复制&#34;&gt;怎么实现主从复制&lt;/h3&gt;
&lt;h4 id=&#34;理论部分&#34;&gt;理论部分&lt;/h4&gt;
&lt;p&gt;主从复制有两个阶段：初始化阶段和运行阶段。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始化阶段：
&lt;ul&gt;
&lt;li&gt;从服务器启动；&lt;/li&gt;
&lt;li&gt;从服务器连接到主机，发送 SYNC 命令；&lt;/li&gt;
&lt;li&gt;主服务器收到 SYNC 命令后，开始执行 BGSAVE 命令，保持当前快照并生成 RDB 文件，同时在此过程中用缓存区记录下这段时间的执行命令，防止数据丢失；&lt;/li&gt;
&lt;li&gt;主服务器执行完 BGSAVE 后，向从服务器发送快照文件，并且也在缓存区记录下这个时期执行的命令；&lt;/li&gt;
&lt;li&gt;从服务器收到快照文件后，丢失所有旧数据，重写载入收到的快照；&lt;/li&gt;
&lt;li&gt;主服务器快照发送完毕后旧向从服务器发送缓存区里记录下的命令；&lt;/li&gt;
&lt;li&gt;从服务器完成快照的输入，开始接收命令请求，执行来自主服务器缓冲区的写命令。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;运行阶段：
&lt;ul&gt;
&lt;li&gt;主服务器每执行一个命令，就会向从服务器发送相同的命令，这个也叫做增量更新。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;实操部分&#34;&gt;实操部分&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yml&#34; data-lang=&#34;yml&#34;&gt;&lt;span class=&#34;l&#34;&gt;// 主机 `redis.conf` 文件&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;role&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;master    // 角色&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;connected_slaves&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;// 从服务器的个数 &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yml&#34; data-lang=&#34;yml&#34;&gt;&lt;span class=&#34;l&#34;&gt;// 从机 `redis.conf` 文件&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;role&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;slave&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;replicaof 主机ip 主机port&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;如果传输的过程中数据丢失了redis-会怎样保证数据的可靠性&#34;&gt;如果传输的过程中数据丢失了，Redis 会怎样保证数据的可靠性？&lt;/h3&gt;
&lt;p&gt;从 Redis2.8 开始，就支持了主从复制的断点续传。master 和 slave 都保存一个 replica offset，里面记录了当前数据的偏移量。slave 会定期的向 master 发送此偏移量，并和自己的偏移量比较，从而知道了 slave 是否还差一些数据，并将数据发送过去。&lt;/p&gt;
&lt;p&gt;同理，当传输过程中数据丢失时，slave 也只保存了丢失前的偏移量，等一段时间后会自动跟 master 比较当前的偏移量。&lt;/p&gt;
&lt;h3 id=&#34;在主从模式下明明一个键过期了为什么还可能会读到&#34;&gt;在主从模式下，明明一个键过期了，为什么还可能会读到？&lt;/h3&gt;
&lt;p&gt;因为 Redis 的从库是无法主从区删除已过期的 key。它的实现策略是通过主库去判断该 key 是否过期，若过期，则删除并且向 Slave 发出删除 key 的指令。又由于 Redis 的主库键过期是采用惰性删除的策略（前文有讲），所以，当读从库时，并不会触发过期判断的策略，从而不删除键。&lt;/p&gt;
&lt;p&gt;解决方法：&lt;/p&gt;
&lt;p&gt;编写一段程序，定期通过 Scan 扫库。扫库的作用是访问 master 里所有的 key，这样就会触发所有 key 的过期检测，从而删除过期的 key。但这样也会极大降低性能。
使用 Redis3.2 以上的版本，因为其新增了一个特性来解决这个问题。增加了 key 是否过期以及对主从库的判断，如果 key 已过期，当前访问的Master则返回 null；当前访问的是从库，且执行的是只读命令也返回 null。源码如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8zMTMzMjA5LTQ3YTNmMzI0NWI5Y2VkMzM_aW1hZ2VNb2dyMi9hdXRvLW9yaWVudC9zdHJpcHxpbWFnZVZpZXcyLzIvdy82NDAvZm9ybWF0L3dlYnA?x-oss-process=image/format,png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
</content>
            
            
            
                
                
                
                    
                    
                    
                        
                            <category scheme="https://marin-man.github.io/posts/" term="posts\" label="posts\" />
                        
                    
                
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://marin-man.github.io/categories/2022/" term="2022" label="2022" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://marin-man.github.io/tags/redis/" term="Redis" label="Redis" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Redis 事务</title>
            <link rel="alternate" type="text/html" href="https://marin-man.github.io/posts/redis-transtation/" />
            <id>https://marin-man.github.io/posts/redis-transtation/</id>
            <updated>2022-02-19T03:35:12&#43;08:00</updated>
            <published>2022-02-19T01:12:52&#43;08:00</published>
            <author>
                    <name>慢慢</name>
                    <uri>https://marin-man.github.io/</uri>
                    <email>marin-man@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">什么是事务？ 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。事务有四个非常重要的……</summary>
            
                <content type="html">&lt;h3 id=&#34;什么是事务&#34;&gt;什么是事务？&lt;/h3&gt;
&lt;p&gt;事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。事务有四个非常重要的特点：ACID。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A(原子性)：原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。&lt;/li&gt;
&lt;li&gt;C(一致性)：事务前后数据的完整性必须保持一致。&lt;/li&gt;
&lt;li&gt;I(隔离性)：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。&lt;/li&gt;
&lt;li&gt;D(持久性)：持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;reids-事务的概念&#34;&gt;Reids 事务的概念&lt;/h3&gt;
&lt;p&gt;Redis 事务的本质是通过 MULTI, EXEC, WATCH 等一组命令的集合。Redis 事务的执行过程为：开启事务 -&amp;gt; 命令队列 -&amp;gt; 序列化 -&amp;gt; 串行执行。&lt;/p&gt;
&lt;p&gt;串行执行即若出错，则后面停止，前面的并没有进行回滚。所以 Redis 默认是不支持事务（没有原子性）操作的。&lt;/p&gt;
&lt;h3 id=&#34;如何让-redis-支持事务&#34;&gt;如何让 Redis 支持事务？&lt;/h3&gt;
&lt;p&gt;Redis 提供了 Watch 命令，使用它我们能够去监视变量，当事务执行出现错误时，其能够去反向执行执行过的操作，从而达到回滚的效果。&lt;/p&gt;
&lt;h3 id=&#34;redis-能保证隔离性吗&#34;&gt;Redis 能保证隔离性吗？&lt;/h3&gt;
&lt;p&gt;慢慢：由于 Redis 是单进程程序，并且它保证在执行事务时不会对事务进行终端，所以不会产生别的线程干扰事务执行的情况，所以保证隔离性。&lt;/p&gt;
</content>
            
            
            
                
                
                
                    
                    
                    
                        
                            <category scheme="https://marin-man.github.io/posts/" term="posts\" label="posts\" />
                        
                    
                
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://marin-man.github.io/categories/2022/" term="2022" label="2022" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://marin-man.github.io/tags/redis/" term="Redis" label="Redis" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Redis 基础</title>
            <link rel="alternate" type="text/html" href="https://marin-man.github.io/posts/redis-based/" />
            <id>https://marin-man.github.io/posts/redis-based/</id>
            <updated>2022-02-19T03:18:24&#43;08:00</updated>
            <published>2022-02-19T01:12:52&#43;08:00</published>
            <author>
                    <name>慢慢</name>
                    <uri>https://marin-man.github.io/</uri>
                    <email>marin-man@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">什么是 Redis？ Redis (Remote Dictionary Server 远程字典服务) 是一个开源的使用 ANSI C 语言编写，支持网络，可基于内存亦可持久化的日志型，key-value 数据库，提供多种语言的 API。 Redis……</summary>
            
                <content type="html">&lt;h3 id=&#34;什么是-redis&#34;&gt;什么是 Redis？&lt;/h3&gt;
&lt;p&gt;Redis (Remote Dictionary Server 远程字典服务) 是一个开源的使用 ANSI C 语言编写，支持网络，可基于内存亦可持久化的日志型，key-value 数据库，提供多种语言的 API。&lt;/p&gt;
&lt;h3 id=&#34;redis-有哪些常用功能&#34;&gt;Redis 有哪些常用功能？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;数据缓存&lt;/li&gt;
&lt;li&gt;数据持久化&lt;/li&gt;
&lt;li&gt;支持事务&lt;/li&gt;
&lt;li&gt;消息队列&lt;/li&gt;
&lt;li&gt;分布式锁&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;小qredis-有哪些数据类型&#34;&gt;小Q：Redis 有哪些数据类型？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;String：Redis 最基础的数据结构。&lt;/li&gt;
&lt;li&gt;Hash：一种键值对的结构，其相对于字符串序列化结构更加直观，并且在更新操作上更加便捷。（底层是 ziplist 或 hashtable）&lt;/li&gt;
&lt;li&gt;List：基于双向链表，可以充当栈和队列的角色。（底层是 ziplist 或 linkedlist）&lt;/li&gt;
&lt;li&gt;Set：用来保证集合中不能有重复元素。（底层是 intset 或 hashtable）&lt;/li&gt;
&lt;li&gt;zset：有序集合，类似于 treeSet，它保留了 set 不能有重复元素外，还将集合里的元素进行排序。（底层是 skiplist）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;小q什么是-ziplist&#34;&gt;小Q：什么是 ziplist？&lt;/h3&gt;
&lt;p&gt;慢慢：ziplist 是由一系列特殊编码的，连续内存快组成的顺序存储结构，类似于数组。ziplist 在内存中是连续的，所以每次插入时，都会重新 malloc 空间，保证其连续性。一般情况下在数据量小的时候使用。&lt;/p&gt;
&lt;h3 id=&#34;小qredis-有哪些使用场景&#34;&gt;小Q：Redis 有哪些使用场景？&lt;/h3&gt;
&lt;p&gt;慢慢：redis 的应用很广泛。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;缓存：减轻 MYSQL 的查询压力，提升系统性能；&lt;/li&gt;
&lt;li&gt;排行榜：利用 Redis 的 zset 实现；&lt;/li&gt;
&lt;li&gt;计算器/限速器：利用 redis 中原子性的自增操作，我们可以统计类似用户点赞、用户访问数等。这类操作如果用 MYSQL，频繁的读写会带来相当大的压力，限速器比较典型的使用场景是限制某个用户访问某个 API 的频率，常用的有抢购时，防止用户疯狂点击开来不必要的压力；&lt;/li&gt;
&lt;li&gt;好友关系：利用集合的一些命令，如交集，并集，差集等，可以方便实现一些共同好友，共同爱好之类的功能；&lt;/li&gt;
&lt;li&gt;消息队列：除了 Redis 自身的发布/订阅模式，我们也可以利用 List 来实现一个队列机制。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;小qredis-如何解决-hash-冲突&#34;&gt;小Q：Redis 如何解决 hash 冲突？&lt;/h3&gt;
&lt;p&gt;慢慢：Redis 采用链地址法解决 hash 冲突。即一个桶里面的元素使用链表保持。但当链表过长时就会导致性能变差。Redis 为了追求快，使用了两个全局哈希表，用于 rehash 操作。&lt;/p&gt;
&lt;h3 id=&#34;小qrehash扩容-的具体操作&#34;&gt;小Q：rehash(扩容) 的具体操作&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;开始时默认使用 hash table1 保持键值对数据，hash table2 没有分配空间。&lt;/li&gt;
&lt;li&gt;当数据越来越多，就会触发 rehash 操作。&lt;/li&gt;
&lt;li&gt;给 hash table2 分配 hash table1 多一倍的空间。&lt;/li&gt;
&lt;li&gt;将 hash1 的数据重映射到 hash2 中&lt;/li&gt;
&lt;li&gt;释放 hash1 的空间。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;重映射的过长不是一次性的，因为这也会造成 redis 长时间阻塞，无法提供服务。它采用渐进式 rehash，每次处理客户端请求的时候，会先从 hash table1 中找到对应的桶，将桶里面的数据移动到 hash table2 中，这样就将 rehash 操作分散到多次请求中，避免耗时阻塞。&lt;/strong&gt;&lt;/p&gt;
</content>
            
            
            
                
                
                
                    
                    
                    
                        
                            <category scheme="https://marin-man.github.io/posts/" term="posts\" label="posts\" />
                        
                    
                
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://marin-man.github.io/categories/2022/" term="2022" label="2022" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://marin-man.github.io/tags/redis/" term="Redis" label="Redis" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Redis 存储</title>
            <link rel="alternate" type="text/html" href="https://marin-man.github.io/posts/redis-store/" />
            <id>https://marin-man.github.io/posts/redis-store/</id>
            <updated>2022-02-19T03:25:35&#43;08:00</updated>
            <published>2022-02-19T01:12:52&#43;08:00</published>
            <author>
                    <name>慢慢</name>
                    <uri>https://marin-man.github.io/</uri>
                    <email>marin-man@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">Redis 是如何持久化的？ Redis 有两种持久化方式： AOF：独立日志文件（主流方式），优先级较高，其是通过将命令写入缓存区，缓冲区再根据策略同步到硬盘，并且还会定期通过 fork() 子进……</summary>
            
                <content type="html">&lt;h3 id=&#34;redis-是如何持久化的&#34;&gt;Redis 是如何持久化的？&lt;/h3&gt;
&lt;p&gt;Redis 有两种持久化方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AOF：独立日志文件（主流方式），优先级较高，其是通过将命令写入缓存区，缓冲区再根据策略同步到硬盘，并且还会定期通过 fork() 子进程对 AOF 进行重写，优化存储空间。&lt;/li&gt;
&lt;li&gt;RDB：采用数据快照的存储方式。通过 fork() 子进程，根据内存生成的临时快照，再存储到硬盘或对原有文件进行原子替换。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;AOF 和 RDB 的区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AOF 文件比 RDB 更新频率高，优先使用 AOF 还原数据；&lt;/li&gt;
&lt;li&gt;AOF 比 RDB 更安全也更大；&lt;/li&gt;
&lt;li&gt;RDB 性能比 AOF 好；&lt;/li&gt;
&lt;li&gt;如果两个都配置了，优先加载 AOF。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;什么是缓存击穿&#34;&gt;什么是缓存击穿？&lt;/h3&gt;
&lt;p&gt;当缓存中的 key 失效时，且同时有很多请求打在 key 上，这个时候的这些请求都会访问到数据库，造成数据库压力变大。&lt;/p&gt;
&lt;p&gt;解决方案：设置热点数据不过时，或采用锁（必要时是分布式锁）保证每个 key 只有一个线程去查询数据库。&lt;/p&gt;
&lt;h3 id=&#34;什么是缓存穿透&#34;&gt;什么是缓存穿透？&lt;/h3&gt;
&lt;p&gt;当很多请求都请求到一个更不不存在的数据时，由于缓存中也肯定没有此数据，所以所有请求都访问到了数据库。&lt;/p&gt;
&lt;p&gt;解决方案：用空对象替代，或者采用布隆过滤器，记录下能找不到的值，下次请求时，如果没有就能直接得到。&lt;/p&gt;
&lt;h3 id=&#34;什么是缓存雪崩&#34;&gt;什么是缓存雪崩？&lt;/h3&gt;
&lt;p&gt;当缓存中大量的值同时失效，并且有很多请求都要请求这些值时，所有请求都会访问到数据库。&lt;/p&gt;
&lt;p&gt;解决方案：通过缓存预热，搭建数据库集群分散压力，服务降级：直接不查数据库，返回默认值。&lt;/p&gt;
&lt;h3 id=&#34;什么是布隆过滤器&#34;&gt;什么是布隆过滤器？&lt;/h3&gt;
&lt;p&gt;布隆过滤器：用于大数据的排重，将每条数据不同 Hash 计算得到不同的指纹，将指纹映射到一个大的按位存储的空间。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：空间和时间效率都很高。&lt;/li&gt;
&lt;li&gt;缺点：随着存入的元素增加，误算率随之增大。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用范围：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;大数据去重：bitmap，Bloom Fiter&lt;/li&gt;
&lt;li&gt;网络爬虫 Url 去重：BitSet + hash，Bloom Filter&lt;/li&gt;
&lt;/ul&gt;
</content>
            
            
            
                
                
                
                    
                    
                    
                        
                            <category scheme="https://marin-man.github.io/posts/" term="posts\" label="posts\" />
                        
                    
                
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://marin-man.github.io/categories/2022/" term="2022" label="2022" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://marin-man.github.io/tags/redis/" term="Redis" label="Redis" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Redis 数据类型</title>
            <link rel="alternate" type="text/html" href="https://marin-man.github.io/posts/redis-data-type/" />
            <id>https://marin-man.github.io/posts/redis-data-type/</id>
            <updated>2022-02-19T17:37:19&#43;08:00</updated>
            <published>2022-02-19T01:12:52&#43;08:00</published>
            <author>
                    <name>慢慢</name>
                    <uri>https://marin-man.github.io/</uri>
                    <email>marin-man@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">Redis 有哪些数据类型 Redis 有 String、List、Hash、Set、ZSet、Bitmap、Hyperloglog 等，下面来详细说下这几种类型的底层实现。 1. String String 底层实……</summary>
            
                <content type="html">&lt;h2 id=&#34;redis-有哪些数据类型&#34;&gt;Redis 有哪些数据类型&lt;/h2&gt;
&lt;p&gt;        Redis 有 String、List、Hash、Set、ZSet、Bitmap、Hyperloglog 等，下面来详细说下这几种类型的底层实现。&lt;/p&gt;
&lt;h3 id=&#34;1-string&#34;&gt;1. String&lt;/h3&gt;
&lt;p&gt;String 底层实现分为两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;整数：长度小于 21 且能够转化为整数的字符串&lt;/li&gt;
&lt;li&gt;SDS (Simple Dynamic String 简单动态字符串)：len 长度 + free 剩余未使用空间 + buf 字符数组&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SDS 的好处：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可以根据 len 快速获取字符串长度&lt;/li&gt;
&lt;li&gt;当修改字符串长度时可以减少内存分配次数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用场景：缓存，限流，计数器，分布式锁，分布式 Session&lt;/p&gt;
&lt;p&gt;基本命令：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-redis&#34; data-lang=&#34;redis&#34;&gt;SET key value                           GET key
MSET key value [key value]              MGET [key1 key2]
INCR key                                DECR key
SETEX key second value                  SETNX key value
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;2-list&#34;&gt;2. List&lt;/h3&gt;
&lt;p&gt;List 在 Reids 中主要用于实现队列或栈，在不同版本有不同的实现方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;旧版本：
&lt;ul&gt;
&lt;li&gt;数据量小时：ZipList 压缩链表&lt;/li&gt;
&lt;li&gt;数据量大时：LinkedList 双向链表&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;新版本：
&lt;ul&gt;
&lt;li&gt;数据量小时：ZipList 压缩链表&lt;/li&gt;
&lt;li&gt;数据量大时：QuickList 快速链表&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ZipList：压缩链表，由一系列特殊编码的连续内存块组成的顺序存储结构，其不固定长度数组，每个元素大小通过元素头的 len 来确定。&lt;/p&gt;
&lt;p&gt;QuickList：也是一个链表结构，只不过链表节点维护一个 ZipList，从而压缩内存空间。&lt;/p&gt;
&lt;p&gt;使用场景：微博关注人时间轴列表，简单队列&lt;/p&gt;
&lt;p&gt;基本命令&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;LPOP # key 移除第一个元素    RPOP # 移除最后一个元素
LPUSH                   RPUSH
LSET key index value   # 通过索引设置列表元素的值
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;3-hash&#34;&gt;3. Hash&lt;/h3&gt;
&lt;p&gt;Hash 是一个类似 Map 的映射结构，其底层有两种实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据量小时：ZipList&lt;/li&gt;
&lt;li&gt;数据量大时：HashTable&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用场景：存储用户信息，用户主页访问量，文章点赞数据&lt;/p&gt;
&lt;p&gt;基本命令&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;HGET key field          HGETALL key         HMGET key field1 field2
HSET key field value    HMSET key field1 value1 field2 value2
HSETNX key field value
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;4-set&#34;&gt;4. Set&lt;/h3&gt;
&lt;p&gt;Set 是一个用于去重的数据结构，底层实现：HashTable 的 Key 部分&lt;/p&gt;
&lt;p&gt;使用场景：点赞，踩，标签，好友关系&lt;/p&gt;
&lt;p&gt;基本命令&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;SADD key member1 member2
SDIFF key1 key2  # 返回第一个集合与其他集合的差异
SINTER key1 key2  # 返回交集
SREM key member1
SPOP key  # 移除集合的一个随机元素
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;5-zset&#34;&gt;5. ZSet&lt;/h4&gt;
&lt;p&gt;ZSet 是一个排序，去重的数据结构框架，其底层有两种实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据量小时：ZipList&lt;/li&gt;
&lt;li&gt;数据量大时：SkipList&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;采用 ZipList 的原因：由于数据量少，O(n) 复杂度的查询和 O(logN) 的查询时间相差不大，同时，ZipList 能很好的压缩内存，节约空间。&lt;/p&gt;
&lt;p&gt;SkipList：跳跃表，其根据数据量会分为多层结构，当查询时从上层往下找，复杂度为 O(logN)，当插入时，会先找到插入的位置，同时生成一个随机数，来表示此节点要生成多少层。SkipList 相较于二叉搜索树的好处是其不用严格的按照左右节点，通过随机数的大小来判断此节点的层数。&lt;/p&gt;
&lt;p&gt;使用场景：排行榜，分页数据&lt;/p&gt;
&lt;p&gt;基本命令：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ZADD key score1 member1 score2 member2
ZCOUNT key min max  # 范围内的成员数
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;6-bitmap&#34;&gt;6. BitMap&lt;/h3&gt;
&lt;p&gt;BitMap 通过每一个来记录一些数据的状态，达到压缩内存的效果。&lt;/p&gt;
&lt;p&gt;使用场景：用户签到，火车座位在不同站点时的状态&lt;/p&gt;
&lt;p&gt;基本命令：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;setbit name 1 1
getbit name 1    # 1
setbit name 3 1
bitcount bittest 0 0  # 表示第一个字节（8位）0 的个数
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;7-hyperloglog&#34;&gt;7. HyperLogLog&lt;/h3&gt;
&lt;p&gt;HyperLogLog 用于基数统计，每个 HyperLogLog 只需要花费 12K 内存，就可以计算接近 2^16 个不同元素的基数，且错误率在 0.82%，这和 set （元素越多内存越大）形成对比。但是 HyperLogLog 只会根据输入元素来计算基数，不会存储元素本身，所以 HyperLogLog 不能输出各个元素。但其也能作为交集，返回元素个数。&lt;/p&gt;
&lt;p&gt;基数：在数组中出现过的值，例如：{1, 3, 5, 7, 5, 7, 8} 的基数集为 {1, 3, 5, 7, 8}&lt;/p&gt;
&lt;p&gt;底层原理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;假设一个人抛硬币，每轮可以抛任意次，但抛到正面就要结束掉。若它抛到为 &lt;code&gt;001&lt;/code&gt;，因为 &lt;code&gt;001&lt;/code&gt; 出现的概率为 1/8，于是我们可以断定抛了 8 次。&lt;/li&gt;
&lt;li&gt;同理，我们可以根据数组中的数据的二进制位 1 出现的位置，来大概估计这组数据中基数的个数，同时设置多个槽，再根据加权平均值得出最终的结果。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基本命令：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;PFADD key element1 element2
PFCOUNT key1 key2  # 查找基数的个数，若多个 key，交集
&lt;/code&gt;&lt;/pre&gt;</content>
            
            
            
                
                
                
                    
                    
                    
                        
                            <category scheme="https://marin-man.github.io/posts/" term="posts\" label="posts\" />
                        
                    
                
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://marin-man.github.io/categories/2022/" term="2022" label="2022" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://marin-man.github.io/tags/redis/" term="Redis" label="Redis" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Redis 数据过期</title>
            <link rel="alternate" type="text/html" href="https://marin-man.github.io/posts/redis-data-died/" />
            <id>https://marin-man.github.io/posts/redis-data-died/</id>
            <updated>2022-02-19T15:00:57&#43;08:00</updated>
            <published>2022-02-19T01:12:52&#43;08:00</published>
            <author>
                    <name>慢慢</name>
                    <uri>https://marin-man.github.io/</uri>
                    <email>marin-man@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">Redis 如果设置键过期？ 可以通过 expire 或 pexpire 命令，客户端可以以秒或毫秒的精度为数据库中的某个键设置生存时间。 与 expire 和 pexpire 命令类似，客户端通过 expireat 和 pexpireat 命令，以秒或毫秒精度给数据库中……</summary>
            
                <content type="html">&lt;p&gt;&lt;img src=&#34;https://marin-man.github.io/images/header-bg.jpg&#34; alt=&#34;header-bg.jpg&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;redis-如果设置键过期&#34;&gt;Redis 如果设置键过期？&lt;/h3&gt;
&lt;p&gt;可以通过 expire 或 pexpire 命令，客户端可以以秒或毫秒的精度为数据库中的某个键设置生存时间。&lt;/p&gt;
&lt;p&gt;与 expire 和 pexpire 命令类似，客户端通过 expireat 和 pexpireat 命令，以秒或毫秒精度给数据库中的某个键设置过期时间。&lt;/p&gt;
&lt;h3 id=&#34;redis-有哪些过期删除策略&#34;&gt;Redis 有哪些过期删除策略？&lt;/h3&gt;
&lt;p&gt;过期策略主要有三种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定时过期：每个设置过期时间的 key 都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好，但会大量占用 CPU 资源，影响 Redis 的响应速度和吞吐量。&lt;/li&gt;
&lt;li&gt;惰性删除：只有当访问一个 key 时，才去判断该 key 是否已经过期，过期则清除。此策略最大化地节省 CPU 资源，但对内存非常不友好。极端情况下可能出现大量过期的 key 没有被再次访问，从而不被清除，占用大量内存。&lt;/li&gt;
&lt;li&gt;定期过期：对惰性删除进行优化，每个一段时间，会扫描 Redis 中所有的 key，相当于都访问一遍，访问时就会去判断此 key 是否过期。该策略是前两者的一个折中方案，通过调整定时扫描的时间间隔和每次扫描的耗时，可以在不同情况下使得 CPU 和内存资源达到最优的平衡效果。&lt;/li&gt;
&lt;/ul&gt;
</content>
            
            
            
                
                
                
                    
                    
                    
                        
                            <category scheme="https://marin-man.github.io/posts/" term="posts\" label="posts\" />
                        
                    
                
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://marin-man.github.io/categories/2022/" term="2022" label="2022" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://marin-man.github.io/tags/redis/" term="Redis" label="Redis" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Redis 高性能</title>
            <link rel="alternate" type="text/html" href="https://marin-man.github.io/posts/redis-x/" />
            <id>https://marin-man.github.io/posts/redis-x/</id>
            <updated>2022-02-19T03:23:29&#43;08:00</updated>
            <published>2022-02-19T01:12:52&#43;08:00</published>
            <author>
                    <name>慢慢</name>
                    <uri>https://marin-man.github.io/</uri>
                    <email>marin-man@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">Redis 有多快？ Redis 每秒读达到了 106 级别，写也达到了 8*105 级别。 Redis 快的原因？ Redis 是基于内存的，以键值对的形式，通过单线程模型和多路复用，并且还使用 pipeline 的管道机制。 什么是多路复用？……</summary>
            
                <content type="html">&lt;h3 id=&#34;redis-有多快&#34;&gt;Redis 有多快？&lt;/h3&gt;
&lt;p&gt;Redis 每秒读达到了 10&lt;sup&gt;6&lt;/sup&gt; 级别，写也达到了 8*10&lt;sup&gt;5&lt;/sup&gt; 级别。&lt;/p&gt;
&lt;h3 id=&#34;redis-快的原因&#34;&gt;Redis 快的原因？&lt;/h3&gt;
&lt;p&gt;Redis 是基于内存的，以键值对的形式，通过单线程模型和多路复用，并且还使用 pipeline 的管道机制。&lt;/p&gt;
&lt;h3 id=&#34;什么是多路复用&#34;&gt;什么是多路复用？&lt;/h3&gt;
&lt;p&gt;Redis 的底层通信也是基于 TCP/IP 协议的。所以每当客户端向服务端发起读/写请求，都必须建立连接。而当连接建立完后，Redis 并不是开启一个线程去处理客户端的请求，而是将其挂载文件符表上，然后使用 epoll 机制，每当有数据传到客户端时，都会通知主线程来进行处理，从而避免了线程创建、切换的开销，并且更简便的实现同步机制。&lt;/p&gt;
&lt;h3 id=&#34;什么是-pipe-管道&#34;&gt;什么是 PIPE 管道？&lt;/h3&gt;
&lt;p&gt;众所周知，Redis 是 C/S 架构，即客户端/服务器模型。&lt;/p&gt;
&lt;p&gt;Redis 的执行命令过程为：发送命令 -&amp;gt; 命令在网络传输 -&amp;gt; 命令在服务器排队 -&amp;gt; 命令执行 -&amp;gt; 返回结果。&lt;/p&gt;
&lt;p&gt;我们知道，CPU 的速度比网络的速度快得多，所以影响 Redis 性能的最大因素是网络。于是 Redis 为了减少网络传输的次数，会采用 pipeline 的批量处理机制，将多个无关命令打包一起，再发送出去，而不是一条条发送。&lt;/p&gt;
&lt;h3 id=&#34;如何做内存上的优化&#34;&gt;如何做内存上的优化？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;控制 key 的数量&lt;/li&gt;
&lt;li&gt;缩减简直对象，降低 redis 内存使用最直接的方式就是缩减键和值的长度&lt;/li&gt;
&lt;li&gt;编码优化，使用更好的数据类型&lt;/li&gt;
&lt;/ul&gt;
</content>
            
            
            
                
                
                
                    
                    
                    
                        
                            <category scheme="https://marin-man.github.io/posts/" term="posts\" label="posts\" />
                        
                    
                
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://marin-man.github.io/categories/2022/" term="2022" label="2022" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://marin-man.github.io/tags/redis/" term="Redis" label="Redis" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Spring Bean 生命周期</title>
            <link rel="alternate" type="text/html" href="https://marin-man.github.io/posts/spring-bean-life/" />
            <id>https://marin-man.github.io/posts/spring-bean-life/</id>
            <updated>2022-02-19T03:08:36&#43;08:00</updated>
            <published>2022-02-19T01:09:28&#43;08:00</published>
            <author>
                    <name>慢慢</name>
                    <uri>https://marin-man.github.io/</uri>
                    <email>marin-man@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">背景 spring 使用了 IOC 模型，让对象存储在了容器中，每当使用时我们可以通过依赖注入的方式获取 bean 对象。 而因为 bean 对象是交由容器来管理的，故就有了生命周期的概念。 先讲下 spring 的容器……</summary>
            
                <content type="html">&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;
&lt;p&gt;spring 使用了 IOC 模型，让对象存储在了容器中，每当使用时我们可以通过依赖注入的方式获取 bean 对象。&lt;/p&gt;
&lt;p&gt;而因为 bean 对象是交由容器来管理的，故就有了生命周期的概念。&lt;/p&gt;
&lt;p&gt;先讲下 spring 的容器有哪些。&lt;/p&gt;
&lt;h2 id=&#34;spring-的容器&#34;&gt;spring 的容器&lt;/h2&gt;
&lt;p&gt;spring 有 BeanFacotry（bean 工厂） 和 ApplicationContext （应用上下文）&lt;/p&gt;
&lt;p&gt;区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;beanfactory 只提供了基础的 bean 存储功能和依赖注入功能，版本控制功能。&lt;/li&gt;
&lt;li&gt;applicationcontext 继承了 beanfactory 的特性，还提供了大量扩展，能根据配置文件 xml 来实现国际化，事件传播，资源加载等，也支持 J2EE 的一些特性。&lt;/li&gt;
&lt;li&gt;BeanFactory 的 bean 是延时加载，ApplicationContext 是非延时加载。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;bean-生命周期&#34;&gt;bean 生命周期&lt;/h2&gt;
&lt;h3 id=&#34;heading&#34;&gt;&lt;/h3&gt;
&lt;p&gt;实例化 spring 容器&lt;/p&gt;
&lt;p&gt;beandifinition bean 定义：通过@compomentscan 来扫描 bean 对象&lt;/p&gt;
&lt;p&gt;解析扫描的对象，从而获取 bean 类的信息，例如抽象类，懒加载等。&lt;/p&gt;
&lt;p&gt;创建 beanDefinition 图纸，将 bean 的信写吸入 map 中&lt;/p&gt;
&lt;p&gt;BeanFactoryPostProcessor 类可以干预原先的类定义，即干预图纸。&lt;/p&gt;
&lt;p&gt;遍历图纸，根据图纸造对象 preInstantiateSingletons() 遍历所有的 bean定义，判断这个类不是抽象的，不是单例的，不是懒加载的，再去创建。&lt;/p&gt;
&lt;p&gt;实例化对象 反射（还没注入到容器）&lt;/p&gt;
&lt;p&gt;缓存注解信息，解析合并后的 beandifinition 对象&lt;/p&gt;
&lt;p&gt;提前暴露一个对象工程 - 循环依赖&lt;/p&gt;
&lt;p&gt;判断实例化的对象里面的属性是否要注入依赖 - 默认需要注入&lt;/p&gt;
&lt;p&gt;回调部分 aware 接口，因为 spring 内置了很多 aware，调用的时机是不同，这里只调用部分。&lt;/p&gt;
&lt;p&gt;执行部分 aware，调用生命周期初始化回调方法&lt;/p&gt;
&lt;p&gt;执行生命周期初始化回调的接口行驶的方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有容器生命周期和bean 生命周期，这部分是bean 生命周期。&lt;/li&gt;
&lt;li&gt;有注解版，配置文件版，接口版&lt;/li&gt;
&lt;li&gt;@PostConstruct 注解的方法是 bean 初始化方法&lt;/li&gt;
&lt;li&gt;@PostDestory 注解的方法是 bean 销毁的方法。&lt;/li&gt;
&lt;li&gt;多个版本可以同时存在。先执行接口版，再执行注解版，最后执行配置文件版。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;完成代理 - aop，事件分发，发布监听&lt;/p&gt;
&lt;p&gt;put 单例池容器&lt;/p&gt;
&lt;p&gt;销毁整个容器对象&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;实例化 spring 容器，创建 beanFactory&lt;/li&gt;
&lt;li&gt;扫描符合 springbean 规则（@bean）的 class  -- 集合&lt;/li&gt;
&lt;li&gt;遍历集合当中的类，封装成一个 beanDefinitionMap 对象&lt;/li&gt;
&lt;li&gt;遍历 beanDefinitionMap 对象&lt;/li&gt;
&lt;li&gt;解析 -- validate&lt;/li&gt;
&lt;li&gt;通过 beanDefinitionMap 获取 类的信息&lt;/li&gt;
&lt;li&gt;得到构造方法 -- 通过算法推断出合理的构造方法&lt;/li&gt;
&lt;li&gt;通过这个合理的构造方法反射实例化一个对象。&lt;/li&gt;
&lt;li&gt;提前暴露工厂  -- 循环依赖&lt;/li&gt;
&lt;li&gt;注入属性 -- 判断是否需要完成属性填充：自动注入&lt;/li&gt;
&lt;li&gt;执行部分的 aware 接口（beannameAware，BeanClassLoaderAware，BeanFactoryAware）&lt;/li&gt;
&lt;li&gt;执行部分 aware 接口和 lifecycle callback 注解版&lt;/li&gt;
&lt;li&gt;若 bean 关联了 BeanPostProcessor 接口，将会调用 postProcessBefforeInitialization 方法，主要对 bean 内容进行更改。&lt;/li&gt;
&lt;li&gt;执行初始化方法 init-method。&lt;/li&gt;
&lt;li&gt;若 bean 关联了 BeanPostProcessor 接口，这时还会调用 postProcessAfterInitialization 方法。&lt;/li&gt;
&lt;li&gt;aop 动态代理，事件分发，发布监听等。&lt;/li&gt;
&lt;li&gt;put singletonobjects 放入单例池&lt;/li&gt;
&lt;li&gt;destroy() 销毁方法&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;invokeBeanFactoryPostProcessors(Factory)
&lt;ul&gt;
&lt;li&gt;扫描，拆改那就 BeanDefinition&lt;/li&gt;
&lt;li&gt;执行 beanFactoryPostProcessors&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
</content>
            
            
            
                
                
                
                    
                    
                    
                        
                            <category scheme="https://marin-man.github.io/posts/" term="posts\" label="posts\" />
                        
                    
                
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://marin-man.github.io/categories/2022/" term="2022" label="2022" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://marin-man.github.io/tags/spring/" term="Spring" label="Spring" />
                            
                        
                    
                
            
        </entry>
    
</feed>
