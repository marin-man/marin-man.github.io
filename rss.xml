<?xml version="1.0" encoding="utf-8"?>






<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>慢慢的个人博客</title>
        <link>https://marin-man.github.io/</link>
        <description>MemE 是一个强大且可高度定制的 GoHugo 博客主题，专为个人博客设计。</description>
        <generator>Hugo 0.92.2 https://gohugo.io/</generator>
        
            <language>zh-CN</language>
        
        
            <managingEditor>marin-man@163.com (慢慢)</managingEditor>
        
        
            <webMaster>marin-man@163.com (慢慢)</webMaster>
        
        
            <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
        
        <lastBuildDate>Mon, 11 Apr 2022 16:52:39 &#43;0800</lastBuildDate>
        
            <atom:link rel="self" type="application/rss&#43;xml" href="https://marin-man.github.io/rss.xml" />
        
        
            <item>
                <title>图数据库</title>
                <link>https://marin-man.github.io/posts/graph-database/</link>
                <guid isPermaLink="true">https://marin-man.github.io/posts/graph-database/</guid>
                <pubDate>Sun, 20 Mar 2022 01:12:52 &#43;0800</pubDate>
                
                    <author>marin-man@163.com (慢慢)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;图数据库（Graph Database）是基于图论实现的一种新型 NoSQL 数据库。他的数据存储结构和数据的查询方式都是以图论为基础的。图论中图的基本元素为节点和边，在图数据库中对应的就是节点和关系。&lt;/p&gt;
&lt;p&gt;在图数据库中，数据与数据之间的关系通过节点和关系构成一个图结构并在此结构上实现数据库的所有特性：对图数据对象进行创建、读取、更新、删除等操作，还有处理事务的能力和高可用性。&lt;/p&gt;
&lt;p&gt;随着社交、电商、金融、零售、物联网等行业的快速发展，现实社会织起了了一张庞大而复杂的关系网，传统数据库很难处理关系运算。图数据库也随之应运而生。&lt;/p&gt;
&lt;p&gt;图数据库有很多的使用场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;社交领域：Facebook, Twitter，Linkedin 用它来管理社交关系，实现好友推荐；&lt;/li&gt;
&lt;li&gt;零售领域 ：eBay，沃尔玛使用它实现商品实时推荐，给买家更好的购物体验；&lt;/li&gt;
&lt;li&gt;金融领域 ：摩根大通，花旗和瑞银等银行在用图数据库做风控处理；&lt;/li&gt;
&lt;li&gt;电信领域 ：Verizon, Orange 和 AT&amp;amp;T 等电信公司依靠图数据库来管理网络，控制访问并支持客户 360；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;neo4j&#34;&gt;Neo4j&lt;/h2&gt;
&lt;p&gt;Neo4j 是由 java 实现的开源 NoSQL 图书库。Neo4j 实现了专业数据库级别的图数据库模型的存储。&lt;/p&gt;
&lt;p&gt;Neo4j 最初的设计动机是为了更好地描述实体之间地联系。现实生活中，每个实体都与周围地其他实体有着千丝万缕的关系，这些关系里存在着大量的潜在信息。但是传统关系型数据库更加注重刻画实体内部的属性，实体与实体之间的关系主要通过外键来实现。因此，在查询一个实体的关系时需要 join 操作，特别时深层次的关系查询需要大量的 join 操作，而 join 操作通常又非常耗时。随着现实世界中关系数据的急剧增加，导致关系型数据库已经主键地难以承载查询海量数据的深层次关系的操作。&lt;/p&gt;
&lt;h3 id=&#34;1-neo4j-的数据类型&#34;&gt;1. Neo4j 的数据类型&lt;/h3&gt;
&lt;p&gt;Neo4j 有两种数据类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;节点：节点类似于 E-R 图中的实体，每一个实体可以有零个或多个属性，这些属性以 key-value 的形式存在。属性没有特殊的类型要求，同时每个节点还具有相应的标签，用来区分不同类型的节点；&lt;/li&gt;
&lt;li&gt;关系：关系也类似于 E-R 图中的边，一个关系有起始节点和终止节点（即边上连接的两个点），与节点一样，关系也能够有自己的属性和标签（指明这个是什么关系：朋友、亲戚等）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;../../images/content/neo4j.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;节点和关系分别采用固定长度存储，每个节点记录的长度为 9 字节，格式为：&lt;code&gt;Node:inUse+nextRelId+nextProId&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;inUse：1 表示该节点被正常使用，0 表示该节点被删除&lt;/li&gt;
&lt;li&gt;nextRelId：该节点的下一个关系 ID&lt;/li&gt;
&lt;li&gt;nextPropId：该节点的下一个属性 ID，属性 Id 通过链表的形式来关联，即有查询该节点下的所有属性，需要通过遍历下一指针的方式找出所有的属性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每个关系记录的长度为 33 字节，格式为： 
&lt;code&gt;Relationship:inUse+firstNode+secondNode+relType+firstPrevRelId+firstNextRelId+secondPrevRelId+secondNextRelId+nextPropId&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;inUse：1 表示该节点被正常使用，0 表示该节点被删除&lt;/li&gt;
&lt;li&gt;nextPropId：该节点的下一个属性 ID&lt;/li&gt;
&lt;li&gt;relType：关系的类型&lt;/li&gt;
&lt;li&gt;firstNode、secondNode：这个关系关联的两个节点，为起始节点和终止节点&lt;/li&gt;
&lt;li&gt;firstPrevRelId、firstNextRelId：起始节点的前一个和后一个关系的 ID&lt;/li&gt;
&lt;li&gt;secondPrevRelId、secondNextRelId：终止节点的前一个和后一个关系的 ID&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-neo4j-遍历方式&#34;&gt;2. Neo4j 遍历方式&lt;/h3&gt;
&lt;p&gt;每个节点记录都包含一个指向该节点的第一个属性的指针和关系链中的第一个关系的指针。要读取一个节点的属性，从指向第一个属性的指针开始，遍历整个单向链表；要找到一个节点的关系，从指向的第一个关系开始，遍历整个双向链表，直到找到了感兴趣的关系&lt;/p&gt;
&lt;p&gt;下面通过一个例子来说明 Neo4j 遍历关系和节点的详细过程。加入在 Neo4j 中存储了 A、B、C、D、E 5 个节点和 R1、R2、R3、R4、R5、R6、R7，7 个关系，它们之间的关系如下：
&lt;img src=&#34;../../images/content/neo4j-1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;假如遍历图中节点 B 的所有关系，只需要向 NODEB-NEXT 方向遍历，直到指向 NULL 为止，可以从下图中看出节点 B 的所有关系为 R1、R2、R3、R4、R5。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/content/neo4j-2.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;通过固定大小的存储记录和指针 ID，只要跟随指针就可以简单地实现遍历并且高速执行。要遍历一个节点到另一个节点的特定关系，在 Neo4j 中只需遍历几个指针，然后执行一些低成本的 ID 计算即可，这相较于全局索引的时间复杂度要低很多，这就是 Neo4j 实现高速遍历的秘密。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从一个给定节点定位关系链中第一个关系的位置，可以通过计算它在关系存储的偏移量来获得。跟获得节点存储位置的方法一样，使用关系 ID 乘以关系记录的固定大小即可找到关系在存储文件中的正确位置&lt;/li&gt;
&lt;li&gt;在关系记录中，搜索第二个字段可以找到第二个节点的 ID，用节点记录大小乘以节点 ID 可以得到节点在存储中的正确位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-neo4j-的存储优化&#34;&gt;3. Neo4j 的存储优化&lt;/h3&gt;
&lt;p&gt;Neo4j 支持存储优化（压缩和内联存储属性值），对于某些短字符的属性可以直接存储在属性文件中。在实际操作中，像邮政编码、电话号码这样的短字符串属性就可以&lt;strong&gt;直接内联到属性存储文件，而不是单独地放在另一个动态存储区&lt;/strong&gt;，这就大幅减少 I/O 操作并且增大吞吐量，因为只有一个文件需要访问。&lt;/p&gt;
&lt;p&gt;除了内联属性值，Neo4j 还可以对属性名称地空间严格维护，例如在社交网络中，有可能会有多个节点存在 first_name 和 last_name 这样的属性，如果将每个属性都逐字写入磁盘上就会造成存储浪费。因此，替代方案是属性名通过属性索引文件从属性存储中间接引用。&lt;strong&gt;属性索引允许所有具有相同名称的属性共享单个记录。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;即使现在的磁盘访问速度已经很快了，但是 CPU 访问磁盘仍然比 CPU 直接访问高速缓存要慢得多。因此，Neo4j 采用了缓存策略，保证那些经常访问的数据可以快速地被多次重复访问。Neo4j 高速缓存地页面置换算法是基于最不经常使用地页置换（LFU）。&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《Neo4j 权威指南》-张帜&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jianshu.com/p/563eb4cde6dd?utm_campaign=haruki&#34;&gt;究竟什么是图数据库，它有哪些应用场景？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
                
                
                
                    
                    
                    
                        
                        
                        
                            
                                <category domain="https://marin-man.github.io/posts/">posts\</category>
                            
                        
                    
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://marin-man.github.io/categories/2022/">2022</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://marin-man.github.io/tags/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93/">图数据库</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>分布式事务</title>
                <link>https://marin-man.github.io/posts/distributed-transaction/</link>
                <guid isPermaLink="true">https://marin-man.github.io/posts/distributed-transaction/</guid>
                <pubDate>Sun, 13 Mar 2022 01:12:52 &#43;0800</pubDate>
                
                    <author>marin-man@163.com (慢慢)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h2 id=&#34;什么是事务&#34;&gt;什么是事务&lt;/h2&gt;
&lt;p&gt;事务有四大特性：原子性、一致性、隔离性、持久性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原子性：事务的指令要么都发生，要么都不发生&lt;/li&gt;
&lt;li&gt;隔离性：不同的事务之间通过一定的策略来防止相互之间的干扰（有读未提交、读已提交、可重复读、串行化读四种）&lt;/li&gt;
&lt;li&gt;一致性：指程序的执行要确保逻辑一致，例如 A 给 B 转 100，那么 A 一定要扣 100（不能只扣 50），B 一定要加 100（不能只加 50）&lt;/li&gt;
&lt;li&gt;持久性：事务执行后的数据一定要持久到硬盘中&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;什么是分布式事务&#34;&gt;什么是分布式事务&lt;/h2&gt;
&lt;p&gt;分布式业务中，我们需要通过 RPC 去调用下游服务，使得整个服务即能解耦，又能完成业务场景。那么如何去保证自身调用多个下游服务后，每个下游服务都能成功或都回退掉，这就需要分布式事务来保证了。&lt;/p&gt;
&lt;p&gt;常见的分布式事务有：2PC、3PC、TCC、本地消息表、MQ 事务消息、Sagas 事务模型等。&lt;/p&gt;
&lt;h2 id=&#34;2pc两阶段提交&#34;&gt;2PC（两阶段提交）&lt;/h2&gt;
&lt;p&gt;两阶段提交使用 XA 协议，必须要依赖于数据库的事务，其原理如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一阶段：事务协调器要求每个涉及到事务的数据库预提交（precommit）此操作，并向协调器反馈是否可以提交&lt;/li&gt;
&lt;li&gt;第二阶段：每个服务有返回可以提交，则协调器发送指令让所有服务提交，否则让所有服务回滚。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;优点：尽量保证数据的强一致性，代码编写也比较简单&lt;/p&gt;
&lt;p&gt;缺点：依赖于数据库提供的事务方案，如果出现一些不基于数据库的功能，如短信发送等，则不能用此模型，同时其为了保证数据的一致性，牺牲了可用性。&lt;/p&gt;
&lt;h2 id=&#34;3pc三阶段提交&#34;&gt;3PC（三阶段提交）&lt;/h2&gt;
&lt;p&gt;三阶段提交和两阶段提交类似，只不过其添加了一层来判断各服务是否可用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一阶段：给各服务发送信号，查看各服务是否可用&lt;/li&gt;
&lt;li&gt;第二阶段：跟 2PC 的第一阶段一样&lt;/li&gt;
&lt;li&gt;第三阶段：跟 2PC 的第二阶段一样&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;优点：与 2PC 相比，先去判断各服务是否可用，从而避免了一些服务不可用，但其他服务还傻乎乎的去执行预提交指令，从而提高服务性能。&lt;/p&gt;
&lt;p&gt;缺点：跟 2PC 一样。&lt;/p&gt;
&lt;h2 id=&#34;tcc补偿事务&#34;&gt;TCC（补偿事务）&lt;/h2&gt;
&lt;p&gt;TCC 核心思想：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作，他分为三个阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Try 阶段：对业务系统做检测以及资源预留&lt;/li&gt;
&lt;li&gt;Confirm 阶段：对业务系统做确认提交，默认 Confirm 阶段是不会出错的（即 Try 成功，Confirm 成功），但也不能绝对保证不会出错&lt;/li&gt;
&lt;li&gt;Cancel 阶段：在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;举个例子，加入 Bob 要向 Smith 转账，思路大概是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事务协调器调用远程接口，把 Smith 和 Bob 的账户冻结起来&lt;/li&gt;
&lt;li&gt;在 Confirm 阶段，执行远程调用的转账操作，转账成功进行解冻&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;参考：&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://cloud.tencent.com/developer/article/1346890&#34;&gt;分布式事务数据库事务CAP定理BASE理论分布式事务案例&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
                
                
                
                    
                    
                    
                        
                        
                        
                            
                                <category domain="https://marin-man.github.io/posts/">posts\</category>
                            
                        
                    
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://marin-man.github.io/categories/2022/">2022</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://marin-man.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>DDos 攻击</title>
                <link>https://marin-man.github.io/posts/network-ddos/</link>
                <guid isPermaLink="true">https://marin-man.github.io/posts/network-ddos/</guid>
                <pubDate>Mon, 28 Feb 2022 01:12:52 &#43;0800</pubDate>
                
                    <author>marin-man@163.com (慢慢)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h2 id=&#34;什么是-ddos-攻击&#34;&gt;什么是 DDos 攻击&lt;/h2&gt;
&lt;p&gt;DDos 攻击就是利用网络上被攻陷的电脑作为肉鸡，然后通过一定方式组合成数量庞大的讲师网络，采用一对多的方式进行控制，向目标系统提出服务请求。&lt;/p&gt;
&lt;h2 id=&#34;有哪些常见的-ddos-攻击&#34;&gt;有哪些常见的 DDos 攻击&lt;/h2&gt;
&lt;p&gt;ICMP Flood、UDP Flood、NTF Flood、SYN Flood、CC Flood、DNS Query Flood、HashDos 等。&lt;/p&gt;
&lt;h3 id=&#34;1-imcp-flood&#34;&gt;1. IMCP Flood&lt;/h3&gt;
&lt;p&gt;CMP 用于在 IP 主机，路由器之间传递控制消息，控制消息是指网络通不通，主机是否可达，路由是否可用等网络本身的消息，虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。通过对目标系统发送海量数据报，就可以令目标主机瘫痪，如果大量发送，就成了洪水攻击。&lt;/p&gt;
&lt;h3 id=&#34;2-udp-flood&#34;&gt;2. UDP Flood&lt;/h3&gt;
&lt;p&gt;UDP 协议是一种无连接的服务，在 UDP Flood 中，攻击者通常发送大量伪造 IP 地址的小 UDP 包冲击 DNS 服务器或 Radius 认证服务器，流媒体视频服务器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;del&gt;上述传统的流量型攻击方式技术含量较低，伤人一千，自损八百，攻击效果通常依赖受控主机本身的网络性能，而且容易被查到攻击源头，单独使用的情况已不常见。&lt;/del&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-ntp-flood&#34;&gt;3. NTP Flood&lt;/h3&gt;
&lt;p&gt;NTP 是标准的基于 UDP 协议传输的网络时间同步协议，由于 UDP 协议的无连接性，方便伪造地址。攻击者使用特殊的数据报，也就是 IP 地址指向作为反射器的服务器，源 IP 地址被伪造成攻击目标的 IP，反射器收到数据包时就被骗了，会将响应数据发送给被攻击对象，耗尽目标网络的带宽资源。一般的 NTP 服务器都有很大的带宽，攻击者可能只需要 1Mbps 的上传带宽欺骗 NTP 服务器，就可以给目标服务器带来几百上千 Mbps 的攻击流量。&lt;/p&gt;
&lt;h3 id=&#34;4-syn-flood&#34;&gt;4. SYN Flood&lt;/h3&gt;
&lt;p&gt;这是一种利用 TCP 协议缺陷，发送大量伪造 TCP 连接请求，从而使得被攻击方资源耗尽的攻击。建立 TCP 连接需要三次握手。SYN Flood 就是用户向服务器发送报文后突然司机或掉线，那么服务器在发出应答报文后就无法收到客户端的确认，这时服务器一般会重试并等待一段时间后再丢弃这个未完成的连接。一个用户出现异常导致服务器的一个线程等待一会并不是大问题，但恶意攻击者大量模拟这种情况，服务器为了维护数以千计的半连接而消耗非常多的资源。&lt;/p&gt;
&lt;p&gt;解决方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;封 ip：通过布隆过滤器，封掉短时间内大量相同的 ip&lt;/li&gt;
&lt;li&gt;减少服务端握手时的等待时间&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;5-cc-攻击&#34;&gt;5. CC 攻击&lt;/h3&gt;
&lt;p&gt;CC 攻击是目前应用层攻击的主要手段之一，借助代理服务器生成指向目标系统的合法请求，实现伪装和 DDos。我们都有这样的体验，访问一个静态页面，即使人多也不需要太长时间，但如果在高峰访问论坛，贴吧，就很慢了，因为服务器需要到数据库中判断访问者是否有读帖，发言等权限。&lt;/p&gt;
&lt;h3 id=&#34;6-dns-query-flood&#34;&gt;6. DNS Query Flood&lt;/h3&gt;
&lt;p&gt;DNS Query Flood 采用的方式是操控大量傀儡机，向域名服务器发送大量的域名解析请求。通常攻击者请求解析的域名是随机生成或网络上根本不存在的域名，由于再本地无法找到对应的结果，服务器必须递归查询上传域名服务器，引起连锁反应。解析过程给服务器带来很大的负载，每秒钟服务解析请求超过一定的数量就会造成 DNS 服务器解析域名超时，从而导致一个网络中域名解析服务的崩塌。&lt;/p&gt;
&lt;h3 id=&#34;7-hashdos&#34;&gt;7. HashDos&lt;/h3&gt;
&lt;p&gt;Hash 碰撞攻击。随着 RESTful 风格的普及，我们默认会使用 json 格式作为数据传递的方式。但 json 转字符串的对象默认会存储在 Hash Table，而 Hash Table 很容易被碰撞攻击。&lt;/p&gt;
</description>
                
                
                
                    
                    
                    
                        
                        
                        
                            
                                <category domain="https://marin-man.github.io/posts/">posts\</category>
                            
                        
                    
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://marin-man.github.io/categories/2022/">2022</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://marin-man.github.io/tags/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/">网络攻防</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>数据链路层</title>
                <link>https://marin-man.github.io/posts/network-link-layer/</link>
                <guid isPermaLink="true">https://marin-man.github.io/posts/network-link-layer/</guid>
                <pubDate>Sun, 20 Feb 2022 01:12:52 &#43;0800</pubDate>
                
                    <author>marin-man@163.com (慢慢)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h3 id=&#34;什么是数据链路层的基本特征&#34;&gt;什么是数据链路层的基本特征&lt;/h3&gt;
&lt;p&gt;数据链路层的基本特征为：封装成帧，透明传输，差错检测。&lt;/p&gt;
&lt;h3 id=&#34;什么是封装成帧&#34;&gt;什么是封装成帧&lt;/h3&gt;
&lt;p&gt;慢慢：封装成帧就是在一段数据的前后分别添加首部和尾部，从而构成一个帧。所有互联网上传送的数据都是以分组（IP 数据报）为传送单位，网络层的 IP 数据报传送到数据链路层就成为帧的数据部分，再添加首部和尾部，构成一个完整的帧。&lt;/p&gt;
&lt;h3 id=&#34;什么是透明传输&#34;&gt;什么是透明传输&lt;/h3&gt;
&lt;p&gt;由于帧的开始和结束的标记使用专门的控制字符。但如果数据中出现了开始或结束字符，我们应当想方法让他们保持原意，于是就得要通过转移字符。让数据链路层看不到妨碍数据传输的东西，就叫做透明传输。&lt;/p&gt;
&lt;h3 id=&#34;什么是差错检测&#34;&gt;什么是差错检测&lt;/h3&gt;
&lt;p&gt;现实中的通信链路都不会是理想的，也就是说比特在传输中可能会出现差错。数据链路层采用循环冗余法（CRC）来检测传输过来的数据是否有差错，如果有，则直接抛弃。&lt;/p&gt;
&lt;h3 id=&#34;什么是-csmacd-协议&#34;&gt;什么是 CSMA/CD 协议&lt;/h3&gt;
&lt;p&gt;CSMA/CD (Carrier Sense Multiple Access with Collision Detection)，即载波监听，多点接入，碰撞检测。&lt;/p&gt;
&lt;p&gt;以前的以太网是使用总线的形式来传输数据，这样就避免不了总线上的不同点同时发送数据的情况。&lt;/p&gt;
&lt;p&gt;多点接入：许多计算机以多点的方式连接在一条总线上。
载波监听：用电子技术检测总线上有没有其他计算机也在发送。不管在发送前还是在发送中，每个站都必须不同地检测信道。在发送前检测信道是为了判断信道没有人发送，获得发送权。在发送中检测信道是为了即使发现有没有其他站地发送和本站发送的碰撞。
碰撞检测：虽然在发送前需要检测信道为空才能发送信息，但也有一种情况发生：两个站都没有检测到信道被占用，并几乎同时发送信息，就像两个小朋友同时举手发言。当发现碰撞检测时，两个站都会取消发送，同时发出人为干扰信号，通知其他点也不要发送。然后执行截断二进制退避算法，双方推迟不同的时间发送数据。&lt;/p&gt;
&lt;p&gt;但现在的网络采用了星形结构来传输，所以不会出现信号在一条线上发生冲突的情况。&lt;/p&gt;
&lt;h3 id=&#34;什么是-mac-地址&#34;&gt;什么是 MAC 地址&lt;/h3&gt;
&lt;p&gt;MAC 地址又称为物理地址或硬件地址。每个网卡，路由器都有一个对应的 MAC 地址。&lt;/p&gt;
</description>
                
                
                
                    
                    
                    
                        
                        
                        
                            
                                <category domain="https://marin-man.github.io/posts/">posts\</category>
                            
                        
                    
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://marin-man.github.io/categories/2022/">2022</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://marin-man.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>网络架构</title>
                <link>https://marin-man.github.io/posts/network-based/</link>
                <guid isPermaLink="true">https://marin-man.github.io/posts/network-based/</guid>
                <pubDate>Sun, 20 Feb 2022 01:12:52 &#43;0800</pubDate>
                
                    <author>marin-man@163.com (慢慢)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h3 id=&#34;什么是-osi-七层模型&#34;&gt;什么是 OSI 七层模型&lt;/h3&gt;
&lt;p&gt;OSI(Open System Interconnection Reference Model)，是一种概念模型，由国际标准化组织提出，一个试图使各种计算机在世界范围内互连为网络的标准架构。&lt;/p&gt;
&lt;p&gt;七层模型为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;物理层：制定底层数据传输的标准，如机械特性，电器特性和功能特性，网线和网卡标准等。&lt;/li&gt;
&lt;li&gt;数据链路层：定义数据的格式，如何传输，如何标识，主要为封装成帧，透明传输，差错检测。&lt;/li&gt;
&lt;li&gt;网络层：定义 IP 编址，定义路由功能。&lt;/li&gt;
&lt;li&gt;传输层：端到端传输数据的基本传输。&lt;/li&gt;
&lt;li&gt;会话层：控制应用层序之间会话能力，如将不同软件数据分发给不同软件。&lt;/li&gt;
&lt;li&gt;表示层：数据格式标识，基本压缩，加密功能等。&lt;/li&gt;
&lt;li&gt;应用层：各种应用程序，包括 web 应用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每一层实现各自的功能和协议，并完成与相邻层的接口通信。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../images/content/network.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;什么是五层模型&#34;&gt;什么是五层模型&lt;/h3&gt;
&lt;p&gt;五层模型将网络分为物理层，数据链路层，网络层，应用层。&lt;/p&gt;
&lt;h3 id=&#34;两者有什么关系呢&#34;&gt;两者有什么关系呢？&lt;/h3&gt;
&lt;p&gt;OSI 七层协议是一个标准，而非实现，五层模型是一个实现的应用模型，五层模型由七层简化合并而来。&lt;/p&gt;
&lt;h3 id=&#34;不同层的数据被称为什么&#34;&gt;不同层的数据被称为什么？&lt;/h3&gt;
&lt;p&gt;在物理层时数据称为比特流，链路层时为帧，网络层时为数据报，数据链路层为字节流/字符流。&lt;/p&gt;
</description>
                
                
                
                    
                    
                    
                        
                        
                        
                            
                                <category domain="https://marin-man.github.io/posts/">posts\</category>
                            
                        
                    
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://marin-man.github.io/categories/2022/">2022</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://marin-man.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>CAP 理论</title>
                <link>https://marin-man.github.io/posts/distribute-cap/</link>
                <guid isPermaLink="true">https://marin-man.github.io/posts/distribute-cap/</guid>
                <pubDate>Sat, 19 Feb 2022 01:12:52 &#43;0800</pubDate>
                
                    <author>marin-man@163.com (慢慢)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h3 id=&#34;什么是-cap-理论&#34;&gt;什么是 CAP 理论&lt;/h3&gt;
&lt;p&gt;CAP 原则指的是一个分布式系统中，Consistency(一致性)，Avaliablity(可用性)，Partition tolerance(分区容错性)，三者不可兼得。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一致性：在分布式环境下，一致性是指数据在多个副本之间能否保持一致的特性。&lt;/li&gt;
&lt;li&gt;可用性：可用性是指系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。&lt;/li&gt;
&lt;li&gt;分区容错性：分区容错性约束了一个分布式系统具有如下特性：分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;为什么三者不能同时满足&#34;&gt;为什么三者不能同时满足&lt;/h3&gt;
&lt;p&gt;假设现在有两台服务器，一台跑 A 服务和数据库 V1，一台跑服务 B 和数据库 V2，V1 和 V2 是同步的。在满足分区容错性下，A 或 B 一台宕机都不会影响到其他服务的执行。但当 V1 和 V2 的通信断开时，数据库就不能同步。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;牺牲一致性：A 用 v1 的数据库，B 用 v2 的数据库，两者都没有同步&lt;/li&gt;
&lt;li&gt;牺牲可用性：禁止 A 和 B 正常服务，直到两种能同步才开启服务。&lt;/li&gt;
&lt;li&gt;牺牲分区容错性：如果不用分区容错性，则整个系统可以不用分布式来搭建，能保证强一致性和可用性，但如果机器挂了，整个服务也崩了。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;什么是-base-理论&#34;&gt;什么是 BASE 理论&lt;/h3&gt;
&lt;p&gt;BASE 就是 Basically Available(基本可用)，Soft state(软状态)，Eventually consistent(最终一致性)，是对 CAP 中一致性和可用性权衡的结果。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基本可用：指分布式在出现不可预知故障的时候，允许损失部分可用性。
&lt;ul&gt;
&lt;li&gt;响应时间上的损失：一个在线搜索引擎需要 0.5s 内返回给用户相应的查询结果，但由于出现异常（比如系统部分机房发送端点或断网故障）查询结果的响应时间增加到了 1~2s&lt;/li&gt;
&lt;li&gt;功能上的损失：在购物高峰时，为了保证购物系统的稳定性，部分消费者可能会被引导到一个降级页面。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;软状态：指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性。
最终一致性：系统中的所有数据副本，在经过一段时间的同步后，最终能够到达一个一致的状态。&lt;/li&gt;
&lt;/ul&gt;
</description>
                
                
                
                    
                    
                    
                        
                        
                        
                            
                                <category domain="https://marin-man.github.io/posts/">posts\</category>
                            
                        
                    
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://marin-man.github.io/categories/2022/">2022</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://marin-man.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Redis Cluster 集群</title>
                <link>https://marin-man.github.io/posts/redis-cluster/</link>
                <guid isPermaLink="true">https://marin-man.github.io/posts/redis-cluster/</guid>
                <pubDate>Sat, 19 Feb 2022 01:12:52 &#43;0800</pubDate>
                
                    <author>marin-man@163.com (慢慢)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h3 id=&#34;什么是-cluster-集群&#34;&gt;什么是 Cluster 集群？&lt;/h3&gt;
&lt;p&gt;Cluster 集群是通过搭建多个主从节点，每对主从节点存储不同的数据，从而扩大存储容量，解决单线程写的瓶颈，增大吞吐量。&lt;/p&gt;
&lt;p&gt;在不考虑哨兵的情况下，Cluster 至少需要三个 master 节点，每个 master 节点至少需要一个 slave。&lt;/p&gt;
&lt;h3 id=&#34;cluster-的优缺点有哪些&#34;&gt;Cluster 的优缺点有哪些？&lt;/h3&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无中心架构；&lt;/li&gt;
&lt;li&gt;数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布；&lt;/li&gt;
&lt;li&gt;可扩展：可线性扩展，动态删除节点。&lt;/li&gt;
&lt;li&gt;高可用：部分节点不可用时，集群仍然可用，并可以通过增加 slave，哨兵等做为数据副本，实现故障自动转移；&lt;/li&gt;
&lt;li&gt;降低运维成本，提高系统的扩展性和可用性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可能不支持多个 key 的混合计算。例如两个 key 分布在不同节点上，就很难只用 redis 对其求交集等。&lt;/li&gt;
&lt;li&gt;分库扩容可能比较复杂。&lt;/li&gt;
&lt;li&gt;client 实现复杂，需要实现 smart client，先得到 key 的具体位置，并且也要定时更新。
数据通过异步复制，不保证数据的强一致性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;如何搭建-cluster-集群&#34;&gt;如何搭建 Cluster 集群？&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;所有的节点的 redis.conf 文件都添加 &lt;code&gt;cluster-enabled yes&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;启动所有节点，同时选择一个节点输入命令 &lt;code&gt;redis-cli --cluster create 节点1IP:端口 节点2IP:端口 …… --cluster-replicas 1&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;如何去得知-key-存储在哪个节点分区&#34;&gt;如何去得知 Key 存储在哪个节点（分区）？&lt;/h3&gt;
&lt;p&gt;现在有三种常用的分区方法：节点取余分区，一致性哈希分区，虚拟槽分区。&lt;/p&gt;
&lt;h4 id=&#34;1-节点取余分区&#34;&gt;1. 节点取余分区&lt;/h4&gt;
&lt;p&gt;对每个 key 进行取余，并根据余数放到不同的分区中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：计算简单&lt;/li&gt;
&lt;li&gt;缺点：当要扩容时，需要把所有数据重新取余一遍。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2-一致性哈希分区&#34;&gt;2. 一致性哈希分区&lt;/h4&gt;
&lt;p&gt;运用哈希环（创建一个大小为 2&lt;sup&gt;32&lt;/sup&gt;-1 的环形数组），每个节点都选择数组中的一个点。当添加 key 时，把 key 也放到数组上面，同时根据顺时针的方式，找到离得最近的节点，存到这个节点里。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：增加或减少节点很容易：当增加节点时，在数组中选择一个位置，并且逆时针将与上一个节点之间的数据都转移到此节点上。&lt;/li&gt;
&lt;li&gt;缺点：数组初始时需要很大，也可以采用链地址法。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;3-虚拟槽分区&#34;&gt;3. 虚拟槽分区&lt;/h4&gt;
&lt;p&gt;预设虚拟槽，槽的大小比节点的大小小得多（即一个节点上有多个虚拟槽），将数据映射到虚拟槽上，将虚拟槽映射到节点上。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：这是 redis 默认的分区方式，扩容或缩容时是以槽为单位，可以自身控制扩容、缩容需要的代价&lt;/li&gt;
&lt;/ul&gt;
</description>
                
                
                
                    
                    
                    
                        
                        
                        
                            
                                <category domain="https://marin-man.github.io/posts/">posts\</category>
                            
                        
                    
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://marin-man.github.io/categories/2022/">2022</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://marin-man.github.io/tags/redis/">Redis</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Redis 主从集群</title>
                <link>https://marin-man.github.io/posts/redis-master/</link>
                <guid isPermaLink="true">https://marin-man.github.io/posts/redis-master/</guid>
                <pubDate>Sat, 19 Feb 2022 01:12:52 &#43;0800</pubDate>
                
                    <author>marin-man@163.com (慢慢)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h3 id=&#34;什么是集群&#34;&gt;什么是集群&lt;/h3&gt;
&lt;p&gt;为了系统的可靠性或扩大系统资源，我们一般会通过多台机器来共享资源、分担费用、共用信道设备及服务等。&lt;/p&gt;
&lt;h3 id=&#34;redis-有哪几种集群模式&#34;&gt;Redis 有哪几种集群模式&lt;/h3&gt;
&lt;p&gt;Redis 场景的集群模式有：主从模式，哨兵模式，cluster 模式。&lt;/p&gt;
&lt;h3 id=&#34;什么是主从集群&#34;&gt;什么是主从集群&lt;/h3&gt;
&lt;p&gt;通过搭建多台 redis 主机，两者间存储相同的数据，从而分散单主机下的请求压力。&lt;/p&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;高可靠性：一方面采用主从机架构，当主机宕机时，能手动将从机顶替主机，防止系统崩溃。另一方面，多台机器都会进行相应的数据持久化操作，从而备份多份数据。&lt;/li&gt;
&lt;li&gt;读写分离策略：从节点可以扩展主库节点的读能力，有效应对大并发量的读操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;故障恢复发杂：因为没有哨兵去检测主机从机之间的状态并处理故障转移，所以我们得要去开发监控程序，当主机宕机时能及时通知我们并手动去切换主从节点。&lt;/li&gt;
&lt;li&gt;主库的写能力收到单机的限制。&lt;/li&gt;
&lt;li&gt;系统的存储能力收到单机的限制。&lt;/li&gt;
&lt;li&gt;主从同步时是通过网络进行传输，难免会出现一些错误，即使有了很多的检错手段，但还是会出现个节点间数据不一致的问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;怎么实现主从复制&#34;&gt;怎么实现主从复制&lt;/h3&gt;
&lt;h4 id=&#34;理论部分&#34;&gt;理论部分&lt;/h4&gt;
&lt;p&gt;主从复制有两个阶段：初始化阶段和运行阶段。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始化阶段：
&lt;ul&gt;
&lt;li&gt;从服务器启动；&lt;/li&gt;
&lt;li&gt;从服务器连接到主机，发送 SYNC 命令；&lt;/li&gt;
&lt;li&gt;主服务器收到 SYNC 命令后，开始执行 BGSAVE 命令，保持当前快照并生成 RDB 文件，同时在此过程中用缓存区记录下这段时间的执行命令，防止数据丢失；&lt;/li&gt;
&lt;li&gt;主服务器执行完 BGSAVE 后，向从服务器发送快照文件，并且也在缓存区记录下这个时期执行的命令；&lt;/li&gt;
&lt;li&gt;从服务器收到快照文件后，丢失所有旧数据，重写载入收到的快照；&lt;/li&gt;
&lt;li&gt;主服务器快照发送完毕后旧向从服务器发送缓存区里记录下的命令；&lt;/li&gt;
&lt;li&gt;从服务器完成快照的输入，开始接收命令请求，执行来自主服务器缓冲区的写命令。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;运行阶段：
&lt;ul&gt;
&lt;li&gt;主服务器每执行一个命令，就会向从服务器发送相同的命令，这个也叫做增量更新。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;实操部分&#34;&gt;实操部分&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yml&#34; data-lang=&#34;yml&#34;&gt;&lt;span class=&#34;l&#34;&gt;// 主机 `redis.conf` 文件&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;role&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;master    // 角色&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;connected_slaves&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;// 从服务器的个数 &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yml&#34; data-lang=&#34;yml&#34;&gt;&lt;span class=&#34;l&#34;&gt;// 从机 `redis.conf` 文件&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;role&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;slave&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;replicaof 主机ip 主机port&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;如果传输的过程中数据丢失了redis-会怎样保证数据的可靠性&#34;&gt;如果传输的过程中数据丢失了，Redis 会怎样保证数据的可靠性？&lt;/h3&gt;
&lt;p&gt;从 Redis2.8 开始，就支持了主从复制的断点续传。master 和 slave 都保存一个 replica offset，里面记录了当前数据的偏移量。slave 会定期的向 master 发送此偏移量，并和自己的偏移量比较，从而知道了 slave 是否还差一些数据，并将数据发送过去。&lt;/p&gt;
&lt;p&gt;同理，当传输过程中数据丢失时，slave 也只保存了丢失前的偏移量，等一段时间后会自动跟 master 比较当前的偏移量。&lt;/p&gt;
&lt;h3 id=&#34;在主从模式下明明一个键过期了为什么还可能会读到&#34;&gt;在主从模式下，明明一个键过期了，为什么还可能会读到？&lt;/h3&gt;
&lt;p&gt;因为 Redis 的从库是无法主从区删除已过期的 key。它的实现策略是通过主库去判断该 key 是否过期，若过期，则删除并且向 Slave 发出删除 key 的指令。又由于 Redis 的主库键过期是采用惰性删除的策略（前文有讲），所以，当读从库时，并不会触发过期判断的策略，从而不删除键。&lt;/p&gt;
&lt;p&gt;解决方法：&lt;/p&gt;
&lt;p&gt;编写一段程序，定期通过 Scan 扫库。扫库的作用是访问 master 里所有的 key，这样就会触发所有 key 的过期检测，从而删除过期的 key。但这样也会极大降低性能。
使用 Redis3.2 以上的版本，因为其新增了一个特性来解决这个问题。增加了 key 是否过期以及对主从库的判断，如果 key 已过期，当前访问的Master则返回 null；当前访问的是从库，且执行的是只读命令也返回 null。源码如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8zMTMzMjA5LTQ3YTNmMzI0NWI5Y2VkMzM_aW1hZ2VNb2dyMi9hdXRvLW9yaWVudC9zdHJpcHxpbWFnZVZpZXcyLzIvdy82NDAvZm9ybWF0L3dlYnA?x-oss-process=image/format,png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
</description>
                
                
                
                    
                    
                    
                        
                        
                        
                            
                                <category domain="https://marin-man.github.io/posts/">posts\</category>
                            
                        
                    
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://marin-man.github.io/categories/2022/">2022</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://marin-man.github.io/tags/redis/">Redis</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Redis 事务</title>
                <link>https://marin-man.github.io/posts/redis-transtation/</link>
                <guid isPermaLink="true">https://marin-man.github.io/posts/redis-transtation/</guid>
                <pubDate>Sat, 19 Feb 2022 01:12:52 &#43;0800</pubDate>
                
                    <author>marin-man@163.com (慢慢)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h3 id=&#34;什么是事务&#34;&gt;什么是事务？&lt;/h3&gt;
&lt;p&gt;事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。事务有四个非常重要的特点：ACID。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A(原子性)：原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。&lt;/li&gt;
&lt;li&gt;C(一致性)：事务前后数据的完整性必须保持一致。&lt;/li&gt;
&lt;li&gt;I(隔离性)：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。&lt;/li&gt;
&lt;li&gt;D(持久性)：持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;reids-事务的概念&#34;&gt;Reids 事务的概念&lt;/h3&gt;
&lt;p&gt;Redis 事务的本质是通过 MULTI, EXEC, WATCH 等一组命令的集合。Redis 事务的执行过程为：开启事务 -&amp;gt; 命令队列 -&amp;gt; 序列化 -&amp;gt; 串行执行。&lt;/p&gt;
&lt;p&gt;串行执行即若出错，则后面停止，前面的并没有进行回滚。所以 Redis 默认是不支持事务（没有原子性）操作的。&lt;/p&gt;
&lt;h3 id=&#34;为什么-redis-不支持回滚操作呢&#34;&gt;为什么 Redis 不支持回滚操作呢？&lt;/h3&gt;
&lt;p&gt;Redis 运行指令是单线程的，同时 Redis 保证了一个事务的所有指令有序执行，即不会插入其他的语句，保证了事务的原子性。所以不会出现不同进行同时修改的问题，所以在程序员不写错代码的情况下是不会出错的，不需要回滚机制。&lt;/p&gt;
&lt;h3 id=&#34;redis-能保证隔离性吗&#34;&gt;Redis 能保证隔离性吗？&lt;/h3&gt;
&lt;p&gt;慢慢：由于 Redis 是单进程程序，并且它保证在执行事务时不会对事务进行终端，所以不会产生别的线程干扰事务执行的情况，所以保证隔离性。&lt;/p&gt;
</description>
                
                
                
                    
                    
                    
                        
                        
                        
                            
                                <category domain="https://marin-man.github.io/posts/">posts\</category>
                            
                        
                    
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://marin-man.github.io/categories/2022/">2022</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://marin-man.github.io/tags/redis/">Redis</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Redis 哨兵集群</title>
                <link>https://marin-man.github.io/posts/redis-sentinel/</link>
                <guid isPermaLink="true">https://marin-man.github.io/posts/redis-sentinel/</guid>
                <pubDate>Sat, 19 Feb 2022 01:12:52 &#43;0800</pubDate>
                
                    <author>marin-man@163.com (慢慢)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h3 id=&#34;什么是哨兵&#34;&gt;什么是哨兵？&lt;/h3&gt;
&lt;p&gt;我们知道，在主从集群的基础上，如果主机宕机的话，我们就得要手动去将从机升级为主机，使系统正常运行。而哨兵就是为了代替我们人的存在，它也是一个独立的进程，不做任何具体的业务，只是来监视主从机的运行状况，并在出现故障时自动处理。&lt;/p&gt;
&lt;h3 id=&#34;为什么要有哨兵集群呢&#34;&gt;为什么要有哨兵集群呢？&lt;/h3&gt;
&lt;p&gt;一个哨兵的情况下，如果哨兵和主机都挂了，那么整个系统就不可用了。为了系统更加高可用，避免出现哨兵宕机，主节点同时宕机而使系统崩溃的情况。&lt;/p&gt;
&lt;h3 id=&#34;哨兵是怎么工作的&#34;&gt;哨兵是怎么工作的？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;每个哨兵都会定时向它所知的 master，slave 以及其他的哨兵发送一条 ping 命令；&lt;/li&gt;
&lt;li&gt;每个节点收到 ping 命令后都会回复 pong；&lt;/li&gt;
&lt;li&gt;如果一个节点距离最后一次回复 pong 的时间超过了 down-after-milliseconds 所规定的值，那么这个实例就会被当前的哨兵标记为主观下线；&lt;/li&gt;
&lt;li&gt;如果一个 master 被标记为主观下线，则哨兵就会以更加短的时间发送信息给 master 以确保真正下线；&lt;/li&gt;
&lt;li&gt;当有了足够数量的哨兵在指定的时间范围内确认 master 的确进入了主观下线状态，则 master 就会转为客观下线状态；&lt;/li&gt;
&lt;li&gt;当 Master 被所有哨兵标记为客观下线，哨兵向所有的 Slave 发送 INFO 命令，重新选举新的 master；&lt;/li&gt;
&lt;li&gt;如果没有足够数量的哨兵同意 master 已下线，并且 master 重新向哨兵发送 ping 回复命令，master 的主观下线状态就会被移除。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;哨兵集群部署简单；&lt;/li&gt;
&lt;li&gt;能够解决 redis 主从模式下的高可用切换问题；&lt;/li&gt;
&lt;li&gt;方便实现 redis 数据节点的线性扩展，轻松突破 reids 单线程瓶颈；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;相对于主从模式要更复杂；&lt;/li&gt;
&lt;li&gt;开启进程会消耗一定的资源；&lt;/li&gt;
&lt;li&gt;哨兵主要针对 redis 主节点的高可用切换，对 redis 的数据节点做失败判断，分为主观下线和客观线性，并不执行故障转移；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;redis-是如何选举主节点的&#34;&gt;Redis 是如何选举主节点的？&lt;/h3&gt;
&lt;p&gt;Redis 选举主节点需要两个步骤，第一个步从哨兵节点中选择一个 Leader，第二步是让这个 leader 在执行故障转移操作。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;选举 Leader：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;哨兵发现 master 节点下线，便把他标记为主观下线，并通知其他节点也对此 master 进行检查。&lt;/li&gt;
&lt;li&gt;哨兵多次判断此 master 为主观下线后，就向其他哨兵广播一条信息，请求同意自己作为 Leader。其他节点收到信息后，如果在此之前没有发送过同意，就能够发送同意（即每个哨兵只能同意一个节点）。&lt;/li&gt;
&lt;li&gt;当某个节点收到的同意数量超过一半时，就升级为 leader，否则再进行一轮选举。（这种选举算法为 Raft 算法）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;故障转移&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Leader 选举完成后就执行故障转移操作：每个 slave 节点都将自己的优先级，offest，runid 发送给 Leader，Leader 根据这三者的顺序选举出最大的节点，将其升级为 master 节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;具体实践&#34;&gt;具体实践&lt;/h3&gt;
&lt;p&gt;在配置好主从的情况下，配置哨兵节点：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-conf&#34; data-lang=&#34;conf&#34;&gt;// sentinel.conf
sentinel monitor 主机名称 主机ip 主机端口 监听个数
sentinel auth-pass 主机名称 主机密码
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;虽然我们在 sentinel 的配置文件中只配置了主节点，没有配置从节点，但哨兵会去主节点中获取从节点的信息，从而实现整个 Redis 的监控。&lt;/p&gt;
&lt;h3 id=&#34;为什么哨兵集群必须部署两个以上的节点呢&#34;&gt;为什么哨兵集群必须部署两个以上的节点呢？&lt;/h3&gt;
&lt;p&gt;假设只有两个哨兵节点，如果 Master 和哨兵1 都宕机了，此时哨兵2知道 Master 宕机，对其进行主观下线，并且想升级为 Leader，但没有其他节点响应，所以 Master 就一直不被切换。&lt;/p&gt;
&lt;h3 id=&#34;在哨兵模式下还会不会出现数据丢失的问题&#34;&gt;在哨兵模式下，还会不会出现数据丢失的问题？&lt;/h3&gt;
&lt;p&gt;哨兵只是为了保证在 Master 挂掉的时候能快速选举出新的 Master，从而保证服务的高可用；并不会处理数据同步间出现的问题。&lt;/p&gt;
&lt;p&gt;数据丢失主要有两方面：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;异步复制导致数据丢失：由于 Master -&amp;gt; Slave 的复制是异步的，如果 Master 还没复制数据到 Slave 就宕机了，并且哨兵把 Slave 选举为 Master，那么这部分数据就丢失了。&lt;/li&gt;
&lt;li&gt;脑裂导致数据丢失：当某个 Master 突然脱离了正常网络（不是宕机，可能是部分网络瘫痪），并且哨兵集群认为它宕机了，重新选举 Master。但这个时候旧 Master 还能顺利的接收客户端发送的数据，而哨兵此时维护新 Master。当旧 Master 网络回复后，则会同步新 Master 的数据，导致数据丢失。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;脑裂的解决方法：通过配置文件设置如果 Master 和 Slave 节点超过一定的时间无法联系，则 Master 拒绝写请求。&lt;/p&gt;
&lt;h3 id=&#34;有什么方式可以实现数据一致呢&#34;&gt;有什么方式可以实现数据一致呢？&lt;/h3&gt;
&lt;p&gt;由 CAP 理论得知，一致性和可用性并不能同时成立。为了达到数据的强一致性，我们必须先暂停下服务，等数据同步完再开启服务。以 RedLock （获取分布式锁）为例：一开始有 5 台 Master 节点（都是作为主节点），每当要获取锁时，需要通过轮询的方式从 5 台 Master 节点中获取锁（短暂的服务停顿，等数据同步），保证超过 1/2 的节点都能获取锁后才能继续执行，否则就会超时，获取锁失败。&lt;/p&gt;
</description>
                
                
                
                    
                    
                    
                        
                        
                        
                            
                                <category domain="https://marin-man.github.io/posts/">posts\</category>
                            
                        
                    
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://marin-man.github.io/categories/2022/">2022</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://marin-man.github.io/tags/redis/">Redis</category>
                                
                            
                        
                    
                
            </item>
        
    </channel>
</rss>
